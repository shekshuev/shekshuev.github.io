---
title: Основы языка SQL
---

# SQL-команды манипулирования данными (DML)

Подмножество языка DML (Data Manipulation Language) включает четыре базовые команды, обеспечивающие выполнение операций над содержимым базы данных:

- `INSERT` — добавление записей.
- `SELECT` — выборка данных.
- `UPDATE` — модификация записей.
- `DELETE` — удаление записей.

## Добавление данных (INSERT)

Инструкция `INSERT` предназначена для ввода в таблицу новых строк (кортежей). Данные могут быть сформированы явным перечислением значений или получены в результате выполнения запроса.

### Базовый синтаксис и одиночная вставка

Наиболее надежным способом добавления данных является явное указание списка целевых столбцов. Это предотвращает ошибки при изменении структуры таблицы (например, при добавлении новых полей).

**Синтаксис:**

```sql
INSERT INTO имя_таблицы (столбец_1, столбец_2, ...)
VALUES (значение_1, значение_2, ...);
```

**Пример:**
Добавление нового сотрудника в таблицу личного состава.

```sql
INSERT INTO personnel (last_name, first_name, rank, birth_date)
VALUES ('Петров', 'Сергей', 'Лейтенант', '1995-05-20');
```

::: warning СООТВЕТСТВИЕ ТИПОВ
Порядок перечисления значений в секции `VALUES` должен строго соответствовать порядку столбцов, указанному в секции `INSERT INTO`. Типы данных значений должны быть совместимы с типами столбцов.
:::

### Пакетная вставка (Bulk Insert)

СУБД PostgreSQL позволяет добавлять несколько строк в рамках одной транзакции, что значительно снижает нагрузку на систему по сравнению с выполнением множества одиночных команд.

```sql
INSERT INTO personnel (last_name, first_name, rank)
VALUES
('Сидоров', 'Алексей', 'Сержант'),
('Кузнецов', 'Дмитрий', 'Рядовой'),
('Смирнов', 'Олег', 'Ефрейтор');
```

### Работа со значениями по умолчанию

Если для столбца в структуре таблицы задано значение `DEFAULT` (или столбец допускает `NULL`), его можно исключить из списка вставки или использовать ключевое слово `DEFAULT`.

```sql
-- Вариант 1: Исключение столбца 'rank' (подставится 'Рядовой')
INSERT INTO personnel (last_name, first_name)
VALUES ('Веселов', 'Николай');

-- Вариант 2: Явное использование ключевого слова
INSERT INTO personnel (last_name, first_name, rank)
VALUES ('Громов', 'Игорь', DEFAULT);
```

### Вставка на основе выборки (INSERT ... SELECT)

Используется для копирования данных из одной таблицы в другую. Секция `VALUES` заменяется на подзапрос `SELECT`.

```sql
-- Перенос сотрудников старше 45 лет в таблицу архива
INSERT INTO personnel_archive (fio, archive_rank, archive_date)
SELECT
last_name || ' ' || first_name, -- Конкатенация строк
rank,
now() -- Текущая дата
FROM personnel
WHERE age(birth_date) > '45 years';
```

### Возврат данных (RETURNING)

Специфическая особенность PostgreSQL. Позволяет получить данные добавленных строк сразу после выполнения вставки, без дополнительного запроса `SELECT`. Это особенно полезно для получения сгенерированных идентификаторов (Primary Key).

```sql
INSERT INTO units (unit_code, location)
VALUES ('7788', 'Москва')
RETURNING unit_id, unit_code; -- Возвращает ID созданной записи
```

### Обработка конфликтов (ON CONFLICT)

При попытке вставки записи, нарушающей ограничение уникальности (`UNIQUE` или `PRIMARY KEY`), возникает ошибка. Конструкция `ON CONFLICT` позволяет задать альтернативное действие (механизм **Upsert** — Update or Insert).

```sql
INSERT INTO inventory (item_serial, item_name, quantity)
VALUES ('SN-12345', 'Радиостанция', 10)
ON CONFLICT (item_serial)
DO UPDATE SET
quantity = inventory.quantity + 10; -- Если серийный номер есть - увеличить кол-во
```

## Удаление данных (DELETE и TRUNCATE)

Для удаления записей из таблиц базы данных в PostgreSQL используются две принципиально различные команды: оператор манипулирования данными `DELETE` и команда очистки `TRUNCATE`.

### Селективное удаление (DELETE)

Команда `DELETE` предназначена для удаления строк, удовлетворяющих заданному условию. Операция производится построчно, что фиксируется в журнале транзакций и инициирует срабатывание соответствующих триггеров.

**Расширенный синтаксис:**

```sql
DELETE FROM имя*таблицы
[ USING имя_смежной_таблицы [, ...] ]
WHERE условие
[ RETURNING  список_выражений ];
```

#### Удаление по условию (Базовый сценарий)

Удаление строк производится на основе логического выражения в предложении `WHERE`. Если выражение возвращает `TRUE`, строка удаляется.

```sql
-- Удаление сотрудника по идентификатору
DELETE FROM personnel
WHERE person_id = 1054;
```

::: warning ВАЖНОСТЬ УСЛОВИЯ
Если предложение `WHERE` отсутствует, из таблицы будут удалены **все** строки. Операция выполняется медленно (построчно).
:::

#### Удаление на основе связей (USING)

Предложение `USING` (специфика PostgreSQL) позволяет использовать в условии отбора данные из других таблиц. Это аналог операции `JOIN` для команды удаления.

**Пример:** Удалить из таблицы `officers` всех офицеров, приписанных к расформированным подразделениям (статус подразделения находится в таблице `units`).

```sql
DELETE FROM officers -- Из какой таблицы удаляем
USING units -- Какую таблицу используем для проверки
WHERE officers.unit_id = units.id
AND units.status = 'DISBANDED';
```

#### Возврат удаленных данных (RETURNING)

Позволяет получить содержимое удаленных строк (например, для логирования или сохранения в архив).

```sql
DELETE FROM personnel
WHERE rank = 'Дезертир'
RETURNING person_id, last_name, now() AS deleted_at;
```

### Полная очистка таблицы (TRUNCATE)

Команда `TRUNCATE` обеспечивает быстрое удаление всех строк. С технической точки зрения относится к DDL, так как пересоздает файлы данных таблицы, а не удаляет строки по одной.

**Синтаксис:**

```sql
TRUNCATE [TABLE] имя_таблицы [ RESTART IDENTITY ] [ CASCADE ];
```

**Особенности:**

- **`RESTART IDENTITY`**: Сбрасывает счетчики автоинкремента (`serial`).
- **`CASCADE`**: Очищает также таблицы, ссылающиеся на данную через внешний ключ.

### Сравнительная характеристика DELETE и TRUNCATE

| Характеристика                | DELETE                                    | TRUNCATE                        |
| :---------------------------- | :---------------------------------------- | :------------------------------ |
| **Тип операции**              | DML (Манипулирование)                     | DDL (Определение структуры)     |
| **Связь с другими таблицами** | Поддерживается (`USING`)                  | Только через `CASCADE`          |
| **Скорость работы**           | Низкая (построчная)                       | Очень высокая (страничная)      |
| **Фильтрация (WHERE)**        | Есть                                      | Нет (удаляется всё)             |
| **Сброс счетчиков**           | Нет                                       | Да (`RESTART IDENTITY`)         |
| **Триггеры**                  | Срабатывают `ON DELETE` для каждой строки | Только `ON TRUNCATE` (один раз) |

::: tip РЕКОМЕНДАЦИЯ
Для полной очистки таблиц (например, справочников или логов) следует использовать `TRUNCATE`. Команду `DELETE` целесообразно применять только при необходимости выборочного удаления записей.
:::

## Модификация данных (UPDATE)

Команда `UPDATE` используется для изменения значений в существующих строках таблицы. Операция не создает новые записи, а лишь обновляет содержимое указанных атрибутов.

### Базовое обновление (Simple Update)

В простейшем случае команда изменяет значения в столбцах для строк, соответствующих условию фильтрации.

**Синтаксис:**

```sql
UPDATE имя_таблицы
SET имя_столбца = выражение [, ...]
[ WHERE условие ]
[ RETURNING * ];
```

**Примеры использования:**

```sql
-- Присвоение фиксированного значения
UPDATE personnel
SET rank = 'Капитан'
WHERE person_id = 1054;

-- Вычисляемое обновление (использование текущего значения)
-- Индексация оклада на 15% для всего личного состава
UPDATE personnel
SET salary = salary * 1.15;
```

::: warning ВНИМАНИЕ
Отсутствие предложения `WHERE` в команде `UPDATE` приведет к изменению указанных столбцов во **всех** строках таблицы. СУБД не запрашивает подтверждения перед выполнением данной операции.
:::

### Обновление на основе других таблиц (UPDATE ... FROM)

Специфическая реализация в PostgreSQL (расширение стандарта SQL) позволяет использовать данные из других таблиц для вычисления новых значений или для фильтрации обновляемых строк. Это аналог операции `JOIN` для модификации данных.

**Синтаксис:**

```sql
UPDATE целевая_таблица
SET целевой_столбец = источник.столбец
FROM таблица_источник AS источник
WHERE целевая_таблица.ключ = источник.ключ
AND [дополнительные условия];
```

**Пример:**
Необходимо обновить статус офицеров, но информация о расформировании подразделений находится в другой таблице (`units`).

```sql
UPDATE officers
SET status = 'В РАСПОРЯЖЕНИИ'
FROM units
WHERE officers.unit_id = units.id -- Условие соединения (JOIN)
AND units.state = 'DISBANDED'; -- Фильтр по таблице-источнику
```

### Возврат измененных данных (RETURNING)

Позволяет просмотреть результат изменений сразу после выполнения команды, не прибегая к дополнительному запросу `SELECT`.

```sql
UPDATE warehouse
SET quantity = quantity - 5
WHERE item_id = 100
RETURNING item_id, quantity AS new_quantity; -- Вернет остаток после списания
```

## Выборка данных (SELECT)

Инструкция `SELECT` является основным инструментом извлечения информации в языке SQL. В отличие от модифицирующих команд, она не изменяет данные, а формирует результирующий набор строк (выборку) на основе заданных критериев.

### Полная структура запроса

Синтаксис команды `SELECT` в PostgreSQL обладает сложной структурой, позволяющей выполнять фильтрацию, группировку, сортировку и объединение данных.

**Формальный синтаксис:**

```sql
[ WITH имя_cte AS ( подзапрос ) [, ...] ]
SELECT [ DISTINCT ] { * | выражение [ [ AS ] псевдоним ] [, ...] }
[ INTO новая_таблица ]
FROM таблица_источник [ [ AS ] псевдоним ]
[ тип_соединения JOIN присоединяемая_таблица ON условие_соединения ]
[ WHERE условие_фильтрации_строк ]
[ GROUP BY выражение_группировки [, ...] ]
[ HAVING условие_фильтрации_групп ]
[ { UNION | INTERSECT | EXCEPT } [ ALL ] запрос ]
[ ORDER BY выражение_сортировки [ ASC | DESC ] [, ...] ]
[ LIMIT число_строк ];
```

::: info ПОРЯДОК ВЫПОЛНЕНИЯ
Важно понимать, что порядок написания предложений (клауз) отличается от логического порядка выполнения запроса СУБД:

1.  `FROM` / `JOIN` (Определение источников данных)
2.  `WHERE` (Фильтрация строк)
3.  `GROUP BY` (Группировка)
4.  `HAVING` (Фильтрация групп)
5.  `SELECT` (Проекция столбцов и вычисления)
6.  `ORDER BY` (Сортировка)
7.  `LIMIT` (Ограничение выдачи)

:::

### Формирование списка выборки (List of Select)

Определяет, какие именно атрибуты (столбцы) попадут в результирующий набор.

- **Символ `*`**: Выбирает все столбцы таблицы.
- **Выражения**: Допускается использование арифметических операций, констант и функций.
- **Псевдонимы (`AS`)**: Позволяют переименовать столбец в итоговой выдаче.

### Управление уникальностью выборки (DISTINCT)

Для исключения избыточности данных в результирующем наборе применяется модификатор `DISTINCT`.

#### Полная уникальность (DISTINCT)

Ключевое слово `DISTINCT`, указанное сразу после `SELECT`, обеспечивает удаление строк, которые являются полными дубликатами друг друга (совпадают значения всех выбранных столбцов).

```sql
-- Получить список всех имеющихся званий (без повторов)
SELECT DISTINCT rank
FROM personnel;
```

#### Выборочная уникальность (DISTINCT ON)

СУБД PostgreSQL поддерживает нестандартное расширение `DISTINCT ON (выражение)`. Данная конструкция позволяет оставить в выборке только **первую** строку для каждой группы значений, определенных в скобках.

**Алгоритм работы:**

1.  Система группирует строки по значениям, указанным в `DISTINCT ON`.
2.  Из каждой группы выбирается **первая** попавшаяся строка.
3.  Остальные строки группы отбрасываются.

::: warning ВАЖНОСТЬ СОРТИРОВКИ
Результат выполнения `DISTINCT ON` является **недетерминированным** (случайным), если не задан строгий порядок сортировки. Для обеспечения предсказуемости выборки использование предложения `ORDER BY` является **обязательным**. Первые поля сортировки должны совпадать с полями `DISTINCT ON`.
:::

**Пример:**
Задача: Найти самого молодого сотрудника в каждом подразделении.

```sql
SELECT DISTINCT ON (unit_id) -- 1. Оставляем по одному сотруднику для каждого unit_id
unit_id,
last_name,
rank,
birth_date
FROM personnel
ORDER BY
unit_id ASC, -- Обязательно: совпадает с DISTINCT ON
birth_date DESC; -- Критерий выбора: сортируем от младших к старшим, берем первого
```

В данном примере система отсортирует сотрудников внутри каждого подразделения по дате рождения и оставит только первую запись (самую позднюю дату, т.е. самого молодого).

### Типы соединений и примеры реализации

Для понимания механизма работы соединений рассматривается взаимодействие двух таблиц:

1.  **Таблица А (personnel):** Список сотрудников. Некоторые сотрудники могут не иметь привязки к подразделению (поле `unit_id` равно `NULL`, например, находятся в распоряжении).
2.  **Таблица В (units):** Справочник подразделений. Некоторые подразделения могут быть пустыми (в них не числится ни одного сотрудника).

| Тип соединения         | Описание               | Результат                                                                                                                                    |
| :--------------------- | :--------------------- | :------------------------------------------------------------------------------------------------------------------------------------------- |
| **[INNER] JOIN**       | Внутреннее соединение  | Возвращает только те строки, для которых найдено совпадение в обеих таблицах (пересечение множеств).                                         |
| **LEFT [OUTER] JOIN**  | Левое внешнее          | Возвращает **все** строки из левой таблицы. Если соответствие в правой таблице не найдено, подставляются значения `NULL`.                    |
| **RIGHT [OUTER] JOIN** | Правое внешнее         | Возвращает **все** строки из правой таблицы. Если соответствие в левой таблице не найдено, подставляются значения `NULL`.                    |
| **FULL [OUTER] JOIN**  | Полное внешнее         | Возвращает объединение строк. Включает данные, которые совпали, а также несовпавшие строки из обеих таблиц (с заполнением пропусков `NULL`). |
| **CROSS JOIN**         | Декартово произведение | Каждая строка левой таблицы соединяется с каждой строкой правой таблицы. Условие `ON` отсутствует.                                           |

#### Внутреннее соединение (INNER JOIN)

**Задача:** Получить список сотрудников, которые **фактически** приписаны к существующим подразделениям. Сотрудники "в распоряжении" и пустые подразделения в отчет не попадают.

```sql
SELECT p.last_name, u.unit_name
FROM personnel AS p
INNER JOIN units AS u ON p.unit_id = u.id;
```

#### Левое внешнее соединение (LEFT JOIN)

**Задача:** Вывести полный список сотрудников с указанием места службы. Если сотрудник не приписан к подразделению, в графе "Подразделение" должен быть пропуск (`NULL`).

```sql
SELECT p.last_name, u.unit_name
FROM personnel AS p -- Левая таблица (Ведущая)
LEFT JOIN units AS u ON p.unit_id = u.id;
```

_Результат:_ В списке будут Иванов (Отдел 1), Петров (Отдел 1) и Сидоров (`NULL`), если у Сидорова нет назначения.

#### Правое внешнее соединение (RIGHT JOIN)

**Задача:** Вывести список всех подразделений и фамилии сотрудников в них. Если подразделение пустое, оно все равно должно отобразиться в отчете.

```sql
SELECT p.last_name, u.unit_name
FROM personnel AS p
RIGHT JOIN units AS u ON p.unit_id = u.id; -- Правая таблица (Ведущая)
```

_Результат:_ В списке будут Отдел 1 (Иванов), Отдел 1 (Петров) и Отдел 2 (`NULL`), если в Отделе 2 никого нет.

#### Полное внешнее соединение (FULL JOIN)

**Задача:** Провести полную сверку списков. Найти всех: и сотрудников без места, и подразделения без людей, и тех, у кого всё в порядке.

```sql
SELECT p.last_name, u.unit_name
FROM personnel AS p
FULL JOIN units AS u ON p.unit_id = u.id;
```

_Результат:_ Самая полная выборка, содержащая все возможные комбинации, включая несоответствия с обеих сторон.

#### Декартово произведение (CROSS JOIN)

**Задача:** Сформировать матрицу графика дежурств (сопоставить каждого сотрудника с каждым днем недели).

```sql
SELECT p.last_name, d.day_name
FROM personnel AS p
CROSS JOIN days_of_week AS d;
```

_Результат:_ Если сотрудников 10, а дней 7, в результате будет 70 строк ($10 \times 7$).

### Фильтрация данных (WHERE) {#where-clause}

Предложение `WHERE` определяет критерии отбора строк (селекции). В результирующий набор попадают только те записи, для которых логическое выражение возвращает истину (`TRUE`). Строки, для которых результат равен `FALSE` или `NULL`, исключаются.

**Основные категории фильтров:**

#### Операторы сравнения и диапазоны

Базовые проверки значений атрибутов.

```sql
SELECT * FROM personnel
WHERE salary > 45000 -- Строго больше
AND rank_id <> 10 -- Не равно
AND birth_date BETWEEN '1990-01-01' AND '1995-12-31'; -- Вхождение в диапазон
```

#### Списки значений (IN)

Проверка на вхождение значения в заданное множество.

```sql
-- Выбрать сотрудников из списка конкретных подразделений
SELECT last_name, unit_id
FROM personnel
WHERE unit_id IN (101, 105, 108);
```

#### Поиск по шаблону (LIKE)

Фильтрация строковых данных с использованием метасимволов (`%` — любая строка, `_` — один символ).

```sql
-- Найти всех сотрудников, чья фамилия начинается на "Иван"
SELECT \* FROM personnel
WHERE last_name LIKE 'Иван%';

-- Найти коды, где третий символ 'A'
SELECT code FROM equipment
WHERE code LIKE '\_\_A%';
```

#### Проверка на неопределенность (IS NULL)

Единственный корректный способ работы с пустыми значениями.

```sql
-- Найти сотрудников, не закрепленных за подразделениями
SELECT last_name
FROM personnel
WHERE unit_id IS NULL;

-- Найти тех, у кого указан телефон (поле не пустое)
SELECT last_name, phone
FROM personnel
WHERE phone IS NOT NULL;
```

#### Сложная логика (AND, OR, NOT)

Комбинирование нескольких условий. Приоритет: `NOT` $\rightarrow$ `AND` $\rightarrow$ `OR`. Для изменения порядка вычислений используются скобки.

```sql
SELECT * FROM personnel
WHERE (rank = 'Капитан' OR rank = 'Майор') -- Звание: Капитан ИЛИ Майор
AND status = 'active' -- И при этом статус: активен
AND NOT unit_id = 999; -- И не из спецотдела 999
```

### Группировка и агрегация (GROUP BY / HAVING)

Используется для анализа данных и вычисления агрегатных значений (сумм, средних, максимумов) в разрезе определенных категорий.

#### Агрегатные функции

- `COUNT(*)` — количество строк.
- `SUM(column)` — сумма значений.
- `AVG(column)` — среднее значение.
- `MIN()` / `MAX()` — минимум и максимум.

#### Логика группировки (GROUP BY)

Собирает строки с одинаковыми значениями указанных столбцов в одну строку результата.

#### Фильтрация групп (HAVING)

Принципиальное отличие от `WHERE`:

- `WHERE` фильтрует строки **до** группировки.
- `HAVING` фильтрует результаты **после** группировки (фильтр по значениям агрегатных функций).

**Пример:** Вывести подразделения, в которых средняя зарплата превышает 50 000 руб.

```sql
SELECT unit_id, AVG(salary) as avg_sal
FROM personnel
WHERE status = 'active' -- 1. Сначала отбираем только действующих
GROUP BY unit_id -- 2. Группируем по подразделениям
HAVING AVG(salary) > 50000; -- 3. Оставляем группы с высокой зарплатой
```

### Сортировка и ограничение (ORDER BY / LIMIT / OFFSET)

#### Сортировка (ORDER BY)

Упорядочивает строки результата.

- `ASC` (по умолчанию) — по возрастанию.
- `DESC` — по убыванию.

::: warning ОСОБЕННОСТЬ МНОЖЕСТВЕННОЙ СОРТИРОВКИ
Параметры сортировки применяются индивидуально к каждому столбцу.
Запись `ORDER BY x, y DESC` означает:

1.  Столбец `x` сортируется по возрастанию (по умолчанию `ASC`).
2.  Столбец `y` сортируется по убыванию (`DESC`).
    Это **не** равнозначно `ORDER BY x DESC, y DESC`.

:::

#### Ограничение выборки (LIMIT)

Определяет максимальное количество возвращаемых строк. Часто используется в связке с `ORDER BY` для получения "Топ-N" записей.

#### Пропуск (OFFSET)

Смещает выборку на указанное количество записей. Используется в связке с сортировкой для реализации логики «Пропустить-N».

```sql
-- Получить 3 сотрудников с самой высокой зарплатой
SELECT last_name, salary
FROM personnel
ORDER BY salary DESC
OFFSET 1 LIMIT 3;
```

### Теоретико-множественные операции

Операторы `UNION`, `INTERSECT` и `EXCEPT` позволяют комбинировать результаты нескольких запросов `SELECT` в один итоговый набор.

**Требования к запросам:**

1.  Одинаковое количество столбцов.
2.  Совместимые типы данных в соответствующих столбцах.
3.  Отсутствие `ORDER BY` и `LIMIT` во вложенных запросах (сортируется только итоговый результат).

| Оператор      | Аналог в теории множеств   | Описание                                                  |
| :------------ | :------------------------- | :-------------------------------------------------------- |
| **UNION**     | Объединение ($A \cup B$)   | Возвращает все строки, находящиеся в $A$ **ИЛИ** в $B$.   |
| **INTERSECT** | Пересечение ($A \cap B$)   | Возвращает строки, которые есть **И** в $A$, **И** в $B$. |
| **EXCEPT**    | Разность ($A \setminus B$) | Возвращает строки из $A$, которых **НЕТ** в $B$.          |

**Ключевое слово ALL:**
По умолчанию операторы удаляют дубликаты. Указание `UNION ALL` сохраняет все строки, включая повторы (работает быстрее, так как не требует проверки уникальности).

### Практическая реализация теоретико-множественных операций

Для демонстрации работы операторов рассмотрим выборку данных из двух логических множеств:

1.  **Множество А:** Офицеры в звании «Капитан» (из таблицы действующего состава `personnel`).
2.  **Множество B:** Офицеры, находящиеся в запасе (из таблицы `reserve`).

#### Объединение (UNION / UNION ALL)

Задача: Получить единый список фамилий всех капитанов (и действующих, и запасных).

```sql
-- Вариант 1: UNION (С удалением дубликатов)
-- Если Иванов есть и там, и там - он будет выведен один раз
SELECT last_name, 'Действующий' as status FROM personnel WHERE rank = 'Капитан'
UNION
SELECT last_name, 'Запас' as status FROM reserve WHERE rank = 'Капитан';

-- Вариант 2: UNION ALL (Сохранение всех записей)
-- Если Иванов есть в обеих таблицах - он будет выведен дважды
SELECT last_name FROM personnel WHERE rank = 'Капитан'
UNION ALL
SELECT last_name FROM reserve WHERE rank = 'Капитан';
```

#### Пересечение (INTERSECT)

Задача: Найти сотрудников, которые числятся в штате, но одновременно фигурируют в списках на отчисление (таблица `dismissal_list`).

```sql
SELECT person_id FROM personnel
INTERSECT
SELECT person_id FROM dismissal_list;
```

_Результат:_ Список ID сотрудников, присутствующих **одновременно** в обеих таблицах.

#### Разность (EXCEPT)

Задача: Получить список подразделений, в которых **нет** ни одного лейтенанта.

```sql
-- Множество A: Все существующие подразделения
SELECT id FROM units
EXCEPT
-- Множество B: Подразделения, где есть лейтенанты
SELECT unit_id FROM personnel WHERE rank = 'Лейтенант';
```

_Результат:_ Из общего списка подразделений вычитаются те, которые вернул второй запрос. Остаются только "свободные" от лейтенантов подразделения.

### Сложные конструкции выборки: Подзапросы и CTE

Для реализации сложной бизнес-логики в языке SQL предусмотрены механизмы вложенных запросов. Они позволяют использовать результат выполнения одного запроса (`SELECT`) в качестве входных данных для другого.

#### Классические подзапросы (Subqueries)

Подзапрос — это инструкция `SELECT`, вложенная в тело другой команды (DML). Подзапросы могут возвращать одиночное значение (скаляр), список значений или таблицу.

**Некоррелированные (независимые) подзапросы.**
Выполняются системой **один раз** перед выполнением основного запроса. Результат подставляется в условие внешнего запроса.

_Пример:_ Найти сотрудников, зарплата которых выше средней по всей организации.

```sql
SELECT last_name, salary
FROM personnel
WHERE salary > (
  SELECT AVG(salary) FROM personnel -- Выполняется 1 раз
);
```

**Коррелированные (зависимые) подзапросы.**
Используют значения из внешнего запроса. Такой подзапрос выполняется повторно **для каждой строки** внешнего запроса, что может существенно снизить производительность на больших объемах данных.

_Пример:_ Найти сотрудников, зарплата которых выше средней **в их подразделении**.

```sql
SELECT outer_t.last_name, outer_t.salary, outer_t.unit_id
FROM personnel AS outer_t
WHERE salary > (
  SELECT AVG(inner_t.salary)
  FROM personnel AS inner_t
  WHERE inner_t.unit_id = outer_t.unit_id -- Ссылка на внешнюю строку
);
```

::: warning ПРОИЗВОДИТЕЛЬНОСТЬ
Использование коррелированных подзапросов требует осторожности. Сложность алгоритма приближается к $O(N^2)$, так как для каждой из $N$ строк внешней таблицы запускается отдельный поиск во внутренней. В большинстве случаев коррелированные подзапросы рекомендуется заменять на `JOIN`.
:::

#### Обобщенные табличные выражения (WITH / CTE)

Конструкция `WITH`, также называемая CTE (Common Table Expressions), позволяет определить именованный временный результирующий набор, существующий только в рамках выполнения одного запроса.

**Синтаксис:**

```sql
WITH имя_cte AS (
    запрос_определения
)
SELECT ... FROM имя_cte ...;
```

**Преимущества CTE перед подзапросами:**

1.  **Структурирование кода:** Сложный запрос разбивается на логические блоки, читаемые сверху вниз.
2.  **Рекурсия:** CTE поддерживают рекурсивные вызовы (необходимо для работы с иерархиями, например, "Начальник -> Подчиненный").
3.  **Повторное использование:** К одной CTE можно обратиться несколько раз в основном запросе (в отличие от подзапроса, код которого придется дублировать).

**Пример (сравнение с подзапросом):**
Рассчитать количество офицеров в подразделениях и соединить со справочником.

```sql
WITH OfficerCounts AS (
  SELECT unit_id, COUNT(\*) as cnt
  FROM personnel
  WHERE rank IN ('Майор', 'Подполковник')
  GROUP BY unit_id
)
SELECT u.location, oc.cnt
FROM units u
JOIN OfficerCounts oc ON u.id = oc.unit_id;
```

#### Сравнительный анализ и оптимизация

В ранних версиях PostgreSQL (до v12) CTE всегда "материализовывались" — результат вычислялся полностью и сохранялся в памяти, что создавало "барьер оптимизации".

В современных версиях планировщик запросов работает гибко:

1.  **Inlining (Встраивание):** Если CTE простая и используется один раз, планировщик подставляет её код в основной запрос (как обычный подзапрос). Это позволяет проталкивать условия (`WHERE`) вглубь выборки.
2.  **Materialization (Материализация):** Если CTE сложная или вызывается многократно, система вычисляет её один раз и кэширует результат.

Оператор имеет возможность принудительно управлять этим поведением:

```sql
-- Принудительная материализация (вычислить и запомнить)
WITH calc_heavy_data AS MATERIALIZED ( ... ) ...

-- Принудительное встраивание (оптимизировать совместно)
WITH simple_filter AS NOT MATERIALIZED ( ... ) ...
```

### Сохранение результата в новую таблицу (SELECT INTO)

Предложение `INTO` (не путать с `INSERT INTO`) создает новую таблицу на основе структуры выборки и наполняет ее данными.

```sql
SELECT last_name, rank, birth_date
INTO personnel_backup_2025
FROM personnel;
```

::: warning ТЕХНИЧЕСКОЕ ПРИМЕЧАНИЕ
Данная команда функционально аналогична `CREATE TABLE AS`, однако `CREATE TABLE AS` является более предпочтительной формой согласно стандарту SQL.
:::

## Выводы по третьему учебному вопросу

Команды манипулирования данными (DML) обеспечивают полный цикл обработки информации в базе данных.

- Оператор `SELECT` обладает наиболее развитым синтаксисом, позволяя выполнять фильтрацию, агрегацию и аналитическую обработку данных без их изменения.
- Команды модификации (`INSERT`, `UPDATE`, `DELETE`) требуют строгого контроля условий выполнения (в частности, предикатов `WHERE`) для обеспечения целостности данных.
- Понимание порядка выполнения запроса и принципов работы соединений (`JOIN`) является ключевым навыком для эффективного извлечения информации из реляционных структур.
