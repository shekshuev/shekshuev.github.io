---
title: Многотабличные запросы
---

<script setup>
import Conversation from "../../../../components/Conversation.vue";
import alexey from "../../../assets/databases/heroes/clerk_alexey.png";
import ivan from "../../../assets/databases/heroes/clerk_fedor.png";
import petr from "../../../assets/databases/heroes/petr_young.png";
import { defineAsyncComponent } from "vue";

const Repl = defineAsyncComponent(() => import("../../../../components/Repl.vue"))
</script>

# Комбинирование наборов данных

## Кожуховский поход

**Осень 1694 года.** Детство кончилось окончательно. То, что начиналось как игры в солдатики на заднем дворе, превратилось в **Кожуховский поход** — грандиозную репетицию будущей войны.

Под Москвой, близ деревни Кожухово, выстроена настоящая земляная крепость. Масштаб пугает: 30 тысяч человек, сотни пушек, километры траншей. Петр решил не просто "пострелять", а отработать всё по-взрослому: осаду, штурм, наведение мостов и, самое главное, — **логистику**. Ведь армия без каши и пороха — это просто толпа мужиков с палками.

Все войско разделено на две враждующие армии, и между ними — пропасть не только ролевая, но и ментальная:

1.  **«Новый строй» (Западная армия)**. Наши старые знакомые: Преображенский и Семеновский полки, плюс полки иноземного строя (Гордона и Лефорта). Ими командует «Генералиссимус» и «Князь-Кесарь» **Федор Ромодановский**. Это — будущее: мундиры, дисциплина, математика.
2.  **«Стрелецкое войско» (Армия обороны)**. Старая гвардия: бородатые стрельцы в цветных кафтанах, дворянская конница. Ими командует Иван Бутурлин, назначенный «Королем Польским». Это — прошлое: бердыши, традиции, бюрократия и вечное недовольство.

![Разговор Петра с дьяками](../../../assets/databases/story/petr_talk_with_clerks_2.png)

В штабной избе стоит дым коромыслом. Снаружи гремят взрывы (Петр любит, чтобы было громко), а внутри идет своя битва — бумажная. Федор сидит, обложенный свитками, как крепость мешками с песком.

С одной стороны стола — аккуратные, разлинованные ведомости «Нового строя». С другой — мятые, залитые элем и салом челобитные от стрелецких сотников, написанные старославянской вязью, которую без пол-литра не разберешь.

<Conversation :phrases="[
    {
        name: 'Петр',
        position: 'left',
        text: 'Федор! Казначейство воет! Я требую единую смету на провиант! У меня две армии, а желудки у всех одинаковые. Сведи мне в один список всех, кто сегодня в строю — и преображенцев, и этих бородатых лентяев!',
        photo: petr
    },
    {
        name: 'Федор',
        position: 'right',
        text: 'Мин херц, да как же их свести? Таблицы-то разные! У наших мы пишем «Сословие и Рост», чтобы знать, кого в гренадеры брать. А у стрельцов — «Звание и Жалование», им лишь бы копейку лишнюю урвать. Столбцы не совпадают, государь!',
        photo: ivan
    },
    {
        name: 'Алексей',
        position: 'right',
        text: 'Не ной, Федька. В SQL для этого придумали UNION. Склеим таблицы по именам, никто и не заметит. Главное — количество ртов посчитать.',
        photo: alexey
    },
    {
        name: 'Федор',
        position: 'right',
        text: 'Легко сказать! Тут еще лекарь наш, немчин, удружил... Решил «дезинфицировать» архив спиртом от холеры. Теперь половина стрелецких списков пахнет сивухой, а чернила поплыли. Я даже не пойму, это «Иван» или «Баран» записан.',
        photo: ivan
    },
    {
        name: 'Алексей',
        position: 'right',
        text: 'Скажем, что это шифровка от шведов. Работай с тем, что есть!',
        photo: alexey
    }
]"/>

Задача перед нами стоит титаническая: взять две разные таблицы — `recruits` (наша элита) и `streltsy` (старая гвардия) — и заставить их работать как единое целое.

Для этого нам понадобится вторая таблица — `streltsy`.

::: details Данные для БД

Мы создадим таблицу `streltsy` и добавим туда людей. Обратите внимание: некоторые имена будут совпадать с рекрутами (для проверки пересечений).

```sql
CREATE TABLE recruits (
    id SERIAL PRIMARY KEY,
    first_name VARCHAR(50),
    last_name VARCHAR(50),
    estate VARCHAR(50), -- Сословие: Дворянин, Мещанин, Крестьянин, Иноземец
    birth_year INTEGER,
    height_cm INTEGER,
    service_start_date DATE
);
INSERT INTO recruits (first_name, last_name, estate, birth_year, height_cm, service_start_date) VALUES
-- Реальные исторические личности
('Сергей', 'Бухвостов', 'Дворянин', 1659, 198, '1683-01-01'), -- Первый солдат, высокий!
('Александр', 'Меншиков', 'Мещанин', 1673, 185, '1686-02-12'), -- Алексашка, молодой
('Франц', 'Лефорт', 'Иноземец', 1656, 178, '1680-05-10'), -- Наставник
('Патрик', 'Гордон', 'Иноземец', 1635, 175, '1680-01-15'), -- Самый старший
('Федор', 'Апраксин', 'Дворянин', 1661, 180, '1683-04-20'),
('Михаил', 'Голицын', 'Дворянин', 1675, 176, '1687-06-01'), -- Совсем юный
('Яков', 'Брюс', 'Иноземец', 1669, 182, '1686-08-14'), -- Брюс
('Аникита', 'Репнин', 'Дворянин', 1668, 184, '1685-03-30'),
('Автоном', 'Головин', 'Дворянин', 1667, 179, '1684-11-20'),
('Иван', 'Бутурлин', 'Дворянин', 1661, 177, '1683-09-12'),
-- Массовка (Дворяне)
('Петр', 'Волков', 'Дворянин', 1668, 185, '1683-06-12'),
('Дмитрий', 'Морозов', 'Дворянин', 1671, 190, '1684-03-01'),
('Николай', 'Новиков', 'Дворянин', 1673, 182, '1685-02-10'),
('Сергей', 'Соловьев', 'Дворянин', 1667, 188, '1683-09-30'),
('Яков', 'Семенов', 'Дворянин', 1669, 184, '1684-05-25'),
('Гаврила', 'Романов', 'Дворянин', 1675, 192, '1685-04-12'),
('Ефим', 'Никитин', 'Дворянин', 1668, 186, '1683-12-01'),
-- Массовка (Крестьяне - их много, они пониже, но есть богатыри)
('Алексей', 'Смирнов', 'Крестьянин', 1665, 175, '1683-05-10'),
('Федор', 'Козлов', 'Крестьянин', 1662, 168, '1683-05-20'),
('Михаил', 'Соколов', 'Крестьянин', 1669, 178, '1683-07-07'),
('Андрей', 'Зайцев', 'Крестьянин', 1660, 165, '1683-04-12'),
('Григорий', 'Титов', 'Крестьянин', 1664, 176, '1683-06-18'),
('Степан', 'Кузнецов', 'Крестьянин', 1661, 169, '1683-05-05'),
('Макар', 'Егоров', 'Крестьянин', 1666, 173, '1683-08-01'),
('Лука', 'Антонов', 'Крестьянин', 1671, 177, '1685-01-20'),
('Илья', 'Муромец', 'Крестьянин', 1660, 195, '1683-02-02'), -- Пасхалка, очень высокий
('Савелий', 'Громов', 'Крестьянин', 1665, 188, '1684-07-15'),
('Прохор', 'Дубов', 'Крестьянин', 1670, 180, '1686-03-03'),
-- Массовка (Мещане)
('Иван', 'Попов', 'Мещанин', 1670, 172, '1684-01-15'),
('Василий', 'Лебедев', 'Мещанин', 1665, 170, '1683-08-22'),
('Павел', 'Борисов', 'Мещанин', 1672, 174, '1684-11-05'),
('Александр', 'Виноградов', 'Мещанин', 1670, 171, '1684-02-14'),
('Тихон', 'Медведев', 'Мещанин', 1663, 167, '1683-10-10'),
('Кузьма', 'Минин', 'Мещанин', 1662, 176, '1683-09-09'), -- Тезка знаменитого
('Ермолай', 'Рыбаков', 'Мещанин', 1668, 169, '1685-06-20'),
-- Еще Иноземцы (для статистики)
('Иоганн', 'Вейс', 'Иноземец', 1660, 176, '1684-01-01'),
('Петер', 'Шмидт', 'Иноземец', 1665, 181, '1685-12-12');

-- Создаем таблицу Стрельцов (структура отличается от recruits!)
CREATE TABLE streltsy (
    id SERIAL PRIMARY KEY,
    first_name VARCHAR(50),
    last_name VARCHAR(50),
    rank VARCHAR(50), -- У рекрутов estate, а тут rank
    birth_year INTEGER,
    salary INTEGER -- У рекрутов height_cm, а тут salary
);

INSERT INTO streltsy (first_name, last_name, rank, birth_year, salary) VALUES
-- 1. КОМАНДОВАНИЕ (Исторические личности)
('Лаврентий', 'Сухарев', 'Полковник', 1655, 150), -- В честь него Сухаревская башня
('Иван', 'Цыклер', 'Полковник', 1660, 140), -- Будущий заговорщик
('Федор', 'Шакловитый', 'Сотник', 1658, 80),
('Иван', 'Черный', 'Сотник', 1662, 75),
('Борис', 'Сапог', 'Десятник', 1665, 40),

-- 2. СТРЕЛЕЦКАЯ МАССОВКА (Типичные фамилии)
('Кузьма', 'Борода', 'Стрелец', 1670, 10),
('Ерофей', 'Хабаров', 'Стрелец', 1665, 12),
('Агап', 'Тихий', 'Стрелец', 1672, 10),
('Прокоп', 'Громкий', 'Десятник', 1668, 25),
('Сидор', 'Лютый', 'Стрелец', 1660, 10),
('Фома', 'Кистенев', 'Стрелец', 1669, 11),
('Епифан', 'Коловрат', 'Стрелец', 1667, 10),
('Никита', 'Пустосвят', 'Стрелец', 1659, 10),
('Савва', 'Морозов', 'Стрелец', 1671, 15), -- Торгует втихаря
('Тихон', 'Хренников', 'Стрелец', 1668, 10),
('Елизар', 'Молот', 'Стрелец', 1666, 12),
('Акакий', 'Башмачкин', 'Писарь', 1675, 8), -- Не совсем стрелец, но в штате
('Остап', 'Бендер', 'Десятник', 1673, 50), -- Великий комбинатор в прошлом
('Паниковский', 'Михаил', 'Стрелец', 1660, 5), -- Ворует гусей
('Шура', 'Балаганов', 'Стрелец', 1674, 10),

-- 3. ПЕРЕСЕЧЕНИЯ С РЕКРУТАМИ (Те самые "хитрецы")
-- Эти люди есть в таблице recruits с такими же именами и годом рождения
('Алексей', 'Смирнов', 'Стрелец', 1665, 10),
('Федор', 'Козлов', 'Стрелец', 1662, 10),
('Иван', 'Иванов', 'Сотник', 1670, 45),
('Михаил', 'Соколов', 'Десятник', 1669, 30),
('Андрей', 'Зайцев', 'Стрелец', 1660, 10),
('Григорий', 'Титов', 'Стрелец', 1664, 10),

-- 4. ЕЩЕ ЛЮДИ
('Василий', 'Теркин', 'Стрелец', 1675, 12), -- Веселый малый
('Степан', 'Калашников', 'Стрелец', 1670, 15),
('Кирилл', 'Туров', 'Стрелец', 1668, 10),
('Мефодий', 'Буквоед', 'Писарь', 1660, 9),
('Добрыня', 'Никитич', 'Сотник', 1655, 100), -- Старая школа
('Алеша', 'Попович', 'Десятник', 1678, 30),
('Илья', 'Муромец', 'Стрелец', 1650, 20), -- Тезка рекрута, но год другой!
('Соловей', 'Разбойник', 'Стрелец', 1665, 10), -- Свистит в строю
('Кощей', 'Бессмертный', 'Полковник', 1600, 200), -- Очень старый стрелец
('Яга', 'Костяная', 'Стряпуха', 1620, 5);
```

:::

<ClientOnly>
<Repl :initial-queries="[
`CREATE TABLE recruits (
    id SERIAL PRIMARY KEY,
    first_name VARCHAR(50),
    last_name VARCHAR(50),
    estate VARCHAR(50), -- Сословие: Дворянин, Мещанин, Крестьянин, Иноземец
    birth_year INTEGER,
    height_cm INTEGER,
    service_start_date DATE
);`,
`INSERT INTO recruits (first_name, last_name, estate, birth_year, height_cm, service_start_date) VALUES
-- Реальные исторические личности
('Сергей', 'Бухвостов', 'Дворянин', 1659, 198, '1683-01-01'), -- Первый солдат, высокий!
('Александр', 'Меншиков', 'Мещанин', 1673, 185, '1686-02-12'), -- Алексашка, молодой
('Франц', 'Лефорт', 'Иноземец', 1656, 178, '1680-05-10'), -- Наставник
('Патрик', 'Гордон', 'Иноземец', 1635, 175, '1680-01-15'), -- Самый старший
('Федор', 'Апраксин', 'Дворянин', 1661, 180, '1683-04-20'),
('Михаил', 'Голицын', 'Дворянин', 1675, 176, '1687-06-01'), -- Совсем юный
('Яков', 'Брюс', 'Иноземец', 1669, 182, '1686-08-14'), -- Брюс
('Аникита', 'Репнин', 'Дворянин', 1668, 184, '1685-03-30'),
('Автоном', 'Головин', 'Дворянин', 1667, 179, '1684-11-20'),
('Иван', 'Бутурлин', 'Дворянин', 1661, 177, '1683-09-12'),
-- Массовка (Дворяне)
('Петр', 'Волков', 'Дворянин', 1668, 185, '1683-06-12'),
('Дмитрий', 'Морозов', 'Дворянин', 1671, 190, '1684-03-01'),
('Николай', 'Новиков', 'Дворянин', 1673, 182, '1685-02-10'),
('Сергей', 'Соловьев', 'Дворянин', 1667, 188, '1683-09-30'),
('Яков', 'Семенов', 'Дворянин', 1669, 184, '1684-05-25'),
('Гаврила', 'Романов', 'Дворянин', 1675, 192, '1685-04-12'),
('Ефим', 'Никитин', 'Дворянин', 1668, 186, '1683-12-01'),
-- Массовка (Крестьяне - их много, они пониже, но есть богатыри)
('Алексей', 'Смирнов', 'Крестьянин', 1665, 175, '1683-05-10'),
('Федор', 'Козлов', 'Крестьянин', 1662, 168, '1683-05-20'),
('Михаил', 'Соколов', 'Крестьянин', 1669, 178, '1683-07-07'),
('Андрей', 'Зайцев', 'Крестьянин', 1660, 165, '1683-04-12'),
('Григорий', 'Титов', 'Крестьянин', 1664, 176, '1683-06-18'),
('Степан', 'Кузнецов', 'Крестьянин', 1661, 169, '1683-05-05'),
('Макар', 'Егоров', 'Крестьянин', 1666, 173, '1683-08-01'),
('Лука', 'Антонов', 'Крестьянин', 1671, 177, '1685-01-20'),
('Илья', 'Муромец', 'Крестьянин', 1660, 195, '1683-02-02'), -- Пасхалка, очень высокий
('Савелий', 'Громов', 'Крестьянин', 1665, 188, '1684-07-15'),
('Прохор', 'Дубов', 'Крестьянин', 1670, 180, '1686-03-03'),
-- Массовка (Мещане)
('Иван', 'Попов', 'Мещанин', 1670, 172, '1684-01-15'),
('Василий', 'Лебедев', 'Мещанин', 1665, 170, '1683-08-22'),
('Павел', 'Борисов', 'Мещанин', 1672, 174, '1684-11-05'),
('Александр', 'Виноградов', 'Мещанин', 1670, 171, '1684-02-14'),
('Тихон', 'Медведев', 'Мещанин', 1663, 167, '1683-10-10'),
('Кузьма', 'Минин', 'Мещанин', 1662, 176, '1683-09-09'), -- Тезка знаменитого
('Ермолай', 'Рыбаков', 'Мещанин', 1668, 169, '1685-06-20'),
-- Еще Иноземцы (для статистики)
('Иоганн', 'Вейс', 'Иноземец', 1660, 176, '1684-01-01'),
('Петер', 'Шмидт', 'Иноземец', 1665, 181, '1685-12-12');`,
`CREATE TABLE streltsy (
    id SERIAL PRIMARY KEY,
    first_name VARCHAR(50),
    last_name VARCHAR(50),
    rank VARCHAR(50), -- У рекрутов estate, а тут rank
    birth_year INTEGER,
    salary INTEGER -- У рекрутов height_cm, а тут salary
);`,
`INSERT INTO streltsy (first_name, last_name, rank, birth_year, salary) VALUES
-- 1. КОМАНДОВАНИЕ (Исторические личности)
('Лаврентий', 'Сухарев', 'Полковник', 1655, 150), -- В честь него Сухаревская башня
('Иван', 'Цыклер', 'Полковник', 1660, 140), -- Будущий заговорщик
('Федор', 'Шакловитый', 'Сотник', 1658, 80),
('Иван', 'Черный', 'Сотник', 1662, 75),
('Борис', 'Сапог', 'Десятник', 1665, 40),
-- 2. СТРЕЛЕЦКАЯ МАССОВКА (Типичные фамилии)
('Кузьма', 'Борода', 'Стрелец', 1670, 10),
('Ерофей', 'Хабаров', 'Стрелец', 1665, 12),
('Агап', 'Тихий', 'Стрелец', 1672, 10),
('Прокоп', 'Громкий', 'Десятник', 1668, 25),
('Сидор', 'Лютый', 'Стрелец', 1660, 10),
('Фома', 'Кистенев', 'Стрелец', 1669, 11),
('Епифан', 'Коловрат', 'Стрелец', 1667, 10),
('Никита', 'Пустосвят', 'Стрелец', 1659, 10),
('Савва', 'Морозов', 'Стрелец', 1671, 15), -- Торгует втихаря
('Тихон', 'Хренников', 'Стрелец', 1668, 10),
('Елизар', 'Молот', 'Стрелец', 1666, 12),
('Акакий', 'Башмачкин', 'Писарь', 1675, 8), -- Не совсем стрелец, но в штате
('Остап', 'Бендер', 'Десятник', 1673, 50), -- Великий комбинатор в прошлом
('Паниковский', 'Михаил', 'Стрелец', 1660, 5), -- Ворует гусей
('Шура', 'Балаганов', 'Стрелец', 1674, 10),
-- Эти люди есть в таблице recruits с такими же именами и годом рождения
('Алексей', 'Смирнов', 'Стрелец', 1665, 10),
('Федор', 'Козлов', 'Стрелец', 1662, 10),
('Иван', 'Иванов', 'Сотник', 1670, 45),
('Михаил', 'Соколов', 'Десятник', 1669, 30),
('Андрей', 'Зайцев', 'Стрелец', 1660, 10),
('Григорий', 'Титов', 'Стрелец', 1664, 10),
-- 4. ЕЩЕ ЛЮДИ
('Василий', 'Теркин', 'Стрелец', 1675, 12), -- Веселый малый
('Степан', 'Калашников', 'Стрелец', 1670, 15),
('Кирилл', 'Туров', 'Стрелец', 1668, 10),
('Мефодий', 'Буквоед', 'Писарь', 1660, 9),
('Добрыня', 'Никитич', 'Сотник', 1655, 100), -- Старая школа
('Алеша', 'Попович', 'Десятник', 1678, 30),
('Илья', 'Муромец', 'Стрелец', 1650, 20), -- Тезка рекрута, но год другой!
('Соловей', 'Разбойник', 'Стрелец', 1665, 10), -- Свистит в строю
('Кощей', 'Бессмертный', 'Полковник', 1600, 200), -- Очень старый стрелец
('Яга', 'Костяная', 'Стряпуха', 1620, 5);`
]"/>
</ClientOnly>

## Операция `UNION`: Сбор всех сил

Петру нужен общий список всех бойцов — и рекрутов, и стрельцов. Для этого используется оператор **`UNION`** (Объединение).

Он работает как клей: берет результат первого запроса и приклеивает к нему снизу результат второго.

**Главные правила:**

1.  Количество столбцов должно совпадать.
2.  Типы данных в столбцах должны быть совместимы (нельзя склеить дату с фамилией).

<Conversation :phrases="[
    {
        name: 'Петр',
        position: 'left',
        text: 'Дай мне просто список: Имя, Фамилия и Год рождения. Мне не важно, стрелец он или рекрут, главное — сколько всего голов кормить!',
        photo: petr
    }
]"/>

Попробуем сделать так:

```sql
-- ОШИБКА! Разное количество столбцов
SELECT * FROM recruits
UNION
SELECT * FROM streltsy;
```

### `UNION` (Без дубликатов)

Если мы используем просто `UNION`, база данных автоматически удалит полностью одинаковые строки (если вдруг Иван Иванов записан дважды с одинаковыми данными).

```sql
SELECT first_name, last_name, birth_year FROM recruits
UNION
SELECT first_name, last_name, birth_year FROM streltsy;
```

### `UNION ALL` (С дубликатами)

Но Петр подозревает, что "Иван Иванов" в полку рекрутов и "Иван Иванов" у стрельцов — это могут быть разные люди (или один, получающий два пайка). Нам нужны **все** записи, даже если они повторяются.

```sql
SELECT first_name, last_name, birth_year FROM recruits
UNION ALL
SELECT first_name, last_name, birth_year FROM streltsy
ORDER BY last_name; -- Сортировка всегда ставится в самом конце
```

Теперь мы видим всех участников маневров единым списком.

## Операция `INTERSECT`: Поиск двойных агентов

<Conversation :phrases="[
    {
        name: 'Петр',
        position: 'left',
        text: 'А теперь найди мне хитрецов! Я слышал, некоторые бегают из лагеря в лагерь. Утром кашу едят у нас, а вечером — у стрельцов. Найди тех, кто есть В ОБОИХ списках!',
        photo: petr
    },
    {
        name: 'Алексей',
        position: 'right',
        text: 'Тут нужен оператор INTERSECT (Пересечение). Он покажет только те строки, которые совпадают в обеих таблицах.',
        photo: alexey
    }
]"/>

Найдем людей с одинаковым Именем, Фамилией и Годом рождения в обеих армиях.

```sql
SELECT first_name, last_name, birth_year FROM recruits
INTERSECT
SELECT first_name, last_name, birth_year FROM streltsy;
```

Вот они, наши "двойные агенты": Алексей Смирнов, Федор Козлов, Михаил Соколов... Лекарю стоит проверить их печень — двойной паек водки даром не проходит.

## Операция `EXCEPT`: Проверка лояльности

И наконец, Петр хочет видеть список **только** своих верных рекрутов. Тех, кого **НЕТ** в списках стрельцов.

<Conversation :phrases="[
    {
        name: 'Петр',
        position: 'left',
        text: 'Убери из моего списка всех, кто хоть раз засветился у стрельцов. Оставь только кристально чистых преображенцев!',
        photo: petr
    }
]"/>

Оператор **`EXCEPT`** (Исключение) берет первый список и вычитает из него все, что нашлось во втором.

```sql
SELECT first_name, last_name, birth_year FROM recruits
EXCEPT
SELECT first_name, last_name, birth_year FROM streltsy;
```

Из списка исчезнут Смирнов, Козлов и прочие "совместители". Останутся только уникальные рекруты.

::: tip Запоминалка от Алексея

- **UNION**: Сложи две кучи в одну (ИЛИ то, ИЛИ это).
- **INTERSECT**: Найди общее (И то, И это).
- **EXCEPT**: Вычти второе из первого (То, НО НЕ это).

:::

## Зачем это нужно? (UNION vs OR)

Петр, глядя на новые списки, задумался. Ему показалось, что писари просто усложняют работу, чтобы выпросить лишний штоф водки.

<Conversation :phrases="[
    {
        name: 'Петр',
        position: 'left',
        text: 'Алексей! К чему эти заморские UNION? Разве нельзя было просто написать: «Выбрать всех, кто Рекрут ИЛИ Стрелец»? Мы же раньше использовали OR, и все работало!',
        photo: petr
    },
    {
        name: 'Федор',
        position: 'right',
        text: 'Мин херц, я пробовал... Но чернильница в меня полетела не просто так.',
        photo: ivan
    },
    {
        name: 'Алексей',
        position: 'right',
        text: 'Государь, OR работает, когда ты ищешь в **одной** книге (таблице). Например: «Найти в рекрутах дворян ИЛИ высоких». А у нас — **две разные книги**. Одна в кожаном переплете (`recruits`), другая — берестяная грамота (`streltsy`). Ты не можешь одним глазом читать две книги сразу, если не сложишь их рядом.',
        photo: alexey
    }
]"/>

Это ключевой момент. Операторы множеств (`UNION`, `INTERSECT`, `EXCEPT`) нужны там, где бессильны обычные условия `WHERE`.

### Разные источники данных.

Оператор `OR` работает внутри одной таблицы. Но часто данные разбросаны. Например, у нас есть `recruits` (текущий призыв) и `streltsy` (старая гвардия). Чтобы получить полный список всех, кто когда-либо держал мушкет, `OR` не поможет. Нужен `UNION`.

```sql
-- Собираем всех Иванов из двух разных таблиц
SELECT first_name, last_name, birth_year FROM recruits WHERE first_name = 'Иван'
UNION
SELECT first_name, last_name, birth_year FROM streltsy WHERE first_name = 'Иван';
```

### Разная структура, но общий смысл.

В таблице `recruits` у нас есть столбец `estate` (сословие), а у стрельцов в таблице `streltsy` этого столбца нет, зато есть `rank` (чин). Мы не можем написать запрос `WHERE estate = ... OR rank = ...`, потому что в первой таблице нет ранга, а во второй — сословия. А вот через `UNION` мы можем склеить их, выбрав только общие столбцы или приведя их к общему виду.

```sql
-- Делаем единый столбец "Статус", склеивая Сословие и Чин
SELECT last_name, estate AS status FROM recruits
UNION ALL
SELECT last_name, rank AS status FROM streltsy;
```

### Сложная логика исключений.

Представьте задачу: «Найти тех, кто есть в списке А, но нет в списке Б».
С помощью `WHERE` и подзапросов (`NOT IN`) это можно написать, но запрос будет громоздким и медленным, как старая пушка. Оператор `EXCEPT` делает это элегантно и быстро: «Взять всех рекрутов МИНУС всех стрельцов». Это математически чистое решение.

```sql
-- Те, кто записан в Рекруты, но кого точно нет в Стрельцах
SELECT first_name, last_name, birth_year FROM recruits
EXCEPT
SELECT first_name, last_name, birth_year FROM streltsy;
```

### Отчеты и Итоговые строки.

Иногда `UNION` используют, чтобы приклеить к списку солдат итоговую строку «ВСЕГО: 100500». Это искусственный прием, но в бумажных отчетах он встречается сплошь и рядом. Мы берем выборку людей и «приклеиваем» к ней снизу одну строку с цифрами.

```sql
-- Список бойцов + строка с итогом внизу
SELECT last_name, height_cm::text FROM recruits WHERE height_cm > 190
UNION ALL
SELECT 'ИТОГО БОГАТЫРЕЙ:', COUNT(*)::text FROM recruits WHERE height_cm > 190;
```

### Рекурсивные запросы.

Есть еще один вид объединения, о котором пока даже Алексей говорит шепотом. Это **Рекурсивные обобщенные табличные выражения (CTE)**.
Представьте, что Петр хочет знать всю цепочку командования: Солдат -> Десятник -> Сотник -> Полковник -> Генерал.
В обычной таблице это сделать сложно. Но с помощью специального `UNION`, который вызывает _сам себя_, можно "пробежаться" по дереву иерархии сверху вниз. Но это — высший пилотаж, который мы освоим на следующих занятиях.

## Выводы по учебному вопросу

Кожуховский поход начался с бюрократической победы. Разрозненные полки «нового строя» и старые стрелецкие сотни наконец-то оказались в одной ведомости. Федор научился смотреть на базу данных не как на одну бесконечную таблицу, а как на набор кирпичиков, которые можно складывать (`UNION`), накладывать друг на друга (`INTERSECT`) и отсекать лишнее (`EXCEPT`).

Теперь Петр видит общую численность войск. Но этого мало. Ему докладывают: «Иван Иванов получил 5 баллов по стрельбе». Но _какой_ это Иван Иванов? Из какого он полка? Кто его командир? Чтобы ответить на эти вопросы, нам придется связать бойцов с их начальниками и вооружением. Этим мы займемся в следующем вопросе, изучая **Многотабличные запросы (JOIN)**.
