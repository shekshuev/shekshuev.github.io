<script setup>
import Conversation from "../../../../components/Conversation.vue";
import alexey from "../../../assets/databases/heroes/clerk_alexey.png";
import ivan from "../../../assets/databases/heroes/clerk_fedor.png";
import petr from "../../../assets/databases/heroes/petr_young.png";
import { defineAsyncComponent } from "vue";

const Repl = defineAsyncComponent(() => import("../../../../components/Repl.vue"))
</script>

# Отбор строк. Поиск по шаблону

## Введение: Эпоха перемен

**1682 год.** Москва кипит. Скончался царь Фёдор Алексеевич, не оставив наследника. Кремль превратился в поле битвы двух враждующих кланов — Милославских и Нарышкиных.

В воздухе пахнет порохом и кровью. Вспыхивает беспощадный Стрелецкий бунт. Разъяренные стрельцы, подстрекаемые Милославскими, врываются в царские палаты. Итогом кровавой недели становится шаткий компромисс, невиданный ранее на Руси: на трон венчают сразу двух царей. Старшего, болезненного Ивана V, и младшего — десятилетнего, пышущего энергией Петра I. Но реальная власть утекает в руки их старшей сестры, жесткой и властной царевны Софьи.

Юного Петра фактически ссылают из Кремля. Его новым домом становится село **Преображенское** под Москвой. Для кого-то это стало бы опалой, но для Петра это — свобода.

Здесь, вдали от душных боярских палат и интриг, он начинает строить свой собственный мир. Одержимый европейскими науками и военным делом, Петр создает **«Потешные войска»**. Поначалу это кажется детской игрой в солдатики, но очень скоро «потешные» превращаются в грозную силу. Именно здесь, на пыльных полях Преображенского, куется будущая гвардия Российской Империи и закладывается фундамент новой армии.

**1686 год.** Наша история начинается здесь, в штабной избе Преображенского полка. Рядом с молодым Петром трудятся двое государственных служащих.

![Разговор Петра с дьяками](../../../assets/databases/story/petr_talk_with_clerks.png)

- **Дьяк Алексей** — тертый калач, опытный администратор. Он повидал немало на своем веку, умеет вести дела с казной и знает, как усмирить бюрократический хаос.
- **Федор Литвинов** — молодой подьячий, сын мелкого приказного. Ему всего 15 лет, он ровесник Петра. Федор попал в Преображенское благодаря острому уму и тяге к порядку. Именно ему предстоит стать «главным по данным» в растущей империи.

<Conversation :phrases="[
    {
        name: 'Петр',
        position: 'left',
        text: 'Алексей! Войско растет не по дням, а по часам. Люди идут со всей Москвы, а у нас в записях — бардак! Кто командует? Где стоят полки? Сколько штыков в строю? Мне нужна полная картина, здесь и сейчас!',
        photo: petr
    },
    {
        name: 'Алексей',
        position: 'right',
        text: 'Не изволь гневаться, государь. Справимся. Федька! Бросай свои перья, берись за дело. Государю нужна полная ведомость всех Потешных полков. Живо!',
        photo: alexey
    },
    {
        name: 'Федор',
        position: 'left',
        text: 'Слушаюсь! Только... таблица огромная, государь. Как мне из неё нужные данные выудить, да чтобы без ошибок?',
        photo: ivan
    }
]"/>

Для начала создадим таблицу `recruits` (Рекруты), которая отражает этот новый, детальный подход к учету личного состава.

<ClientOnly>
<Repl :initial-queries="[
`CREATE TABLE recruits (
    id SERIAL PRIMARY KEY,
    first_name VARCHAR(50),
    last_name VARCHAR(50),
    estate VARCHAR(50), -- Сословие: Дворянин, Мещанин, Крестьянин, Иноземец
    birth_year INTEGER,
    height_cm INTEGER, 
    service_start_date DATE
);`,
`INSERT INTO recruits (first_name, last_name, estate, birth_year, height_cm, service_start_date) VALUES
-- Реальные исторические личности
('Сергей', 'Бухвостов', 'Дворянин', 1659, 198, '1683-01-01'), -- Первый солдат, высокий!
('Александр', 'Меншиков', 'Мещанин', 1673, 185, '1686-02-12'), -- Алексашка, молодой
('Франц', 'Лефорт', 'Иноземец', 1656, 178, '1680-05-10'), -- Наставник
('Патрик', 'Гордон', 'Иноземец', 1635, 175, '1680-01-15'), -- Самый старший
('Федор', 'Апраксин', 'Дворянин', 1661, 180, '1683-04-20'),
('Михаил', 'Голицын', 'Дворянин', 1675, 176, '1687-06-01'), -- Совсем юный
('Яков', 'Брюс', 'Иноземец', 1669, 182, '1686-08-14'), -- Брюс
('Аникита', 'Репнин', 'Дворянин', 1668, 184, '1685-03-30'),
('Автоном', 'Головин', 'Дворянин', 1667, 179, '1684-11-20'),
('Иван', 'Бутурлин', 'Дворянин', 1661, 177, '1683-09-12'),
-- Массовка (Дворяне)
('Петр', 'Волков', 'Дворянин', 1668, 185, '1683-06-12'),
('Дмитрий', 'Морозов', 'Дворянин', 1671, 190, '1684-03-01'),
('Николай', 'Новиков', 'Дворянин', 1673, 182, '1685-02-10'),
('Сергей', 'Соловьев', 'Дворянин', 1667, 188, '1683-09-30'),
('Яков', 'Семенов', 'Дворянин', 1669, 184, '1684-05-25'),
('Гаврила', 'Романов', 'Дворянин', 1675, 192, '1685-04-12'),
('Ефим', 'Никитин', 'Дворянин', 1668, 186, '1683-12-01'),
-- Массовка (Крестьяне - их много, они пониже, но есть богатыри)
('Алексей', 'Смирнов', 'Крестьянин', 1665, 175, '1683-05-10'),
('Федор', 'Козлов', 'Крестьянин', 1662, 168, '1683-05-20'),
('Михаил', 'Соколов', 'Крестьянин', 1669, 178, '1683-07-07'),
('Андрей', 'Зайцев', 'Крестьянин', 1660, 165, '1683-04-12'),
('Григорий', 'Титов', 'Крестьянин', 1664, 176, '1683-06-18'),
('Степан', 'Кузнецов', 'Крестьянин', 1661, 169, '1683-05-05'),
('Макар', 'Егоров', 'Крестьянин', 1666, 173, '1683-08-01'),
('Лука', 'Антонов', 'Крестьянин', 1671, 177, '1685-01-20'),
('Илья', 'Муромец', 'Крестьянин', 1660, 195, '1683-02-02'), -- Пасхалка, очень высокий
('Савелий', 'Громов', 'Крестьянин', 1665, 188, '1684-07-15'),
('Прохор', 'Дубов', 'Крестьянин', 1670, 180, '1686-03-03'),
-- Массовка (Мещане)
('Иван', 'Попов', 'Мещанин', 1670, 172, '1684-01-15'),
('Василий', 'Лебедев', 'Мещанин', 1665, 170, '1683-08-22'),
('Павел', 'Борисов', 'Мещанин', 1672, 174, '1684-11-05'),
('Александр', 'Виноградов', 'Мещанин', 1670, 171, '1684-02-14'),
('Тихон', 'Медведев', 'Мещанин', 1663, 167, '1683-10-10'),
('Кузьма', 'Минин', 'Мещанин', 1662, 176, '1683-09-09'), -- Тезка знаменитого
('Ермолай', 'Рыбаков', 'Мещанин', 1668, 169, '1685-06-20'),
-- Еще Иноземцы (для статистики)
('Иоганн', 'Вейс', 'Иноземец', 1660, 176, '1684-01-01'),
('Петер', 'Шмидт', 'Иноземец', 1665, 181, '1685-12-12');`
]"/>
</ClientOnly>

## Команда `SELECT`: Читаем летопись

<Conversation :phrases="[
      {
          name: 'Петр',
          position: 'left',
          text: 'Ну что, Федор? Таблица готова, чернила высохли. Показывай, кого мы там понабрали!',
          photo: petr
      },
      {
          name: 'Федор',
          position: 'right',
          text: 'Готово, мин херц. Но в книге десятки записей... Как мне их все разом тебе представить?',
          photo: ivan
      },
      {
          name: 'Алексей',
          position: 'right',
          text: 'Не суетись. Используй команду SELECT. Это как приказ: «Выбрать». Скажи базе, что хочешь увидеть, и она покажет.',
          photo: alexey
      }
  ]"/>

Базовый синтаксис прост:

```sql
SELECT [столбец 1], [столбец 2] FROM [таблица];
```

### Выборка всех данных (`*`)

Если нужно увидеть **всё и сразу**, используем символ "звездочка" `*`.

```sql
SELECT * FROM recruits;
```

Это удобно для быстрого взгляда на таблицу, но опасно, если в ней миллионы строк. Петр смотрит на длинный список и хмурится: слишком много лишнего. ID, даты... Глаза разбегаются.

::: details Важный совет (Best Practices)
В реальной службе (и в коде программ) старайтесь **всегда перечислять столбцы явно**.

1.  **Экономия:** Зачем тащить из базы дату рождения, если нужны только имена?
2.  **Надежность:** Если структуру таблицы изменят (добавят секретный столбец), ваш код с `SELECT *` может сломаться или выдать тайну.

:::

### Выбор конкретных столбцов

<Conversation :phrases="[
    {
        name: 'Петр',
        position: 'left',
        text: 'Слишком мелко! Мне не нужны номера и даты поступления. Дай мне только Имя, Фамилию и Рост. Хочу видеть, есть ли богатыри!',
        photo: petr
    }
]"/>

Перечисляем только то, что нужно, через запятую:

```sql
SELECT first_name, last_name, height_cm FROM recruits;
```

Теперь список чист и понятен.

## Выражения и арифметика в запросе

SQL — это не просто кладовщик, это еще и счетовод. Мы можем менять данные прямо на лету, не меняя их в самой таблице.

### Объединение строк (Конкатенация)

Вместо двух колонок "Имя" и "Фамилия" сделаем одну красивую — "Боец". В PostgreSQL строки склеиваются оператором `||`.

```sql
SELECT first_name || ' ' || last_name, estate FROM recruits;
```

### Математика

<Conversation :phrases="[
    {
        name: 'Петр',
        position: 'left',
        text: 'Федька, ты мне тут года рождения написал... 1660, 1675... Мне считать лень! Скажи быстро, сколько им лет сейчас, в 1686-м году?',
        photo: petr
    },
    {
        name: 'Федор',
        position: 'right',
        text: 'Сей момент! Сейчас вычту год рождения из текущего года...',
        photo: ivan
    }
]"/>

Мы можем использовать арифметические знаки `+`, `-`, `*`, `/`.
Посчитаем возраст рекрутов (на момент 1686 года):

```sql
SELECT first_name,
       last_name,
       1686 - birth_year
FROM recruits;
```

## Псевдонимы (`AS`)

Результат прошлого запроса выглядит так: столбец называется `?column?` или как формула. Непорядок.
Дадим столбцам красивые имена (псевдонимы) с помощью `AS`. Если в названии есть пробелы или русские буквы, берем их в **двойные кавычки**.

```sql
SELECT first_name || ' ' || last_name AS "Полное имя",
       1686 - birth_year AS "Возраст"
FROM recruits;
```

## Убираем дубликаты (`DISTINCT`)

<Conversation :phrases="[
    {
        name: 'Петр',
        position: 'left',
        text: 'Алексей, какие вообще сословия у нас представлены? Вижу дворян, вижу крестьян... Кто еще есть? Не читай мне весь список, просто перечисли виды.',
        photo: petr
    },
    {
        name: 'Алексей',
        position: 'right',
        text: 'Для этого, государь, есть слово DISTINCT. Оно убирает повторы и оставляет только уникальные значения.',
        photo: alexey
    }
]"/>

Узнаем, какие уникальные сословия (`estate`) есть в нашем войске:

```sql
SELECT DISTINCT estate FROM recruits;
```

Результат будет коротким: `Дворянин`, `Крестьянин`, `Мещанин`, `Иноземец`.

## Фильтрация данных (`WHERE`)

Выборка — это хорошо. Но Петру редко нужны **все**. Ему нужны конкретные люди для конкретных задач.
Для этого используется оператор `WHERE` (ГДЕ). Он оставляет только те строки, где условие истинно (`true`).

Синтаксис:

```sql
SELECT ... FROM ... WHERE [условие];
```

## Простые сравнения

Петр формирует первую гренадерскую роту. Туда берут только высоких.

<Conversation :phrases="[
    {
        name: 'Петр',
        position: 'left',
        text: 'Федор! Мне нужны великаны. Выпиши мне всех, кто выше 180 сантиметров. Остальные пусть пока в обозе сидят.',
        photo: petr
    }
]"/>

Используем операторы сравнения: `>`, `<`, `=`, `>=`, `<=`, `<>` (не равно).

```sql
SELECT first_name, last_name, height_cm
FROM recruits
WHERE height_cm > 180;
```

А теперь найдем всех иностранцев (Иноземцев), чтобы Петр мог попрактиковаться в немецком и голландском языках.

```sql
SELECT first_name, last_name, estate
FROM recruits
WHERE estate = 'Иноземец';
```

## Логические операторы (`AND`, `OR`)

Жизнь сложнее одного условия.

<Conversation :phrases="[
    {
        name: 'Петр',
        position: 'left',
        text: 'Так, нужны толковые офицеры. Найди мне дворян. Но не старых дедов, а молодых, кто родился после 1665 года!',
        photo: petr
    }
]"/>

- `AND` (И) — оба условия должны быть верны.
- `OR` (ИЛИ) — хотя бы одно условие верно.

```sql
SELECT first_name, last_name, estate, birth_year
FROM recruits
WHERE estate = 'Дворянин' AND birth_year > 1665;
```

А теперь найдем всех, кто годится либо в гренадеры (высокие, > 185), либо в иноземные инструкторы (сословие 'Иноземец').

```sql
SELECT first_name, last_name, estate, height_cm
FROM recruits
WHERE height_cm > 185 OR estate = 'Иноземец';
```

## Диапазоны и Списки (`BETWEEN`, `IN`)

Чтобы не писать длинные цепочки `OR` и `AND`, есть сокращения.

### `IN` (В списке)

Петр хочет собрать полк из простых людей: крестьян и мещан.

```sql
-- Вместо: WHERE estate = 'Крестьянин' OR estate = 'Мещанин'
SELECT first_name, last_name, estate
FROM recruits
WHERE estate IN ('Крестьянин', 'Мещанин');
```

### `BETWEEN` (Между)

Ищем ровесников Петра (родившихся между 1670 и 1675 годами).

```sql
-- Вместо: WHERE birth_year >= 1670 AND birth_year <= 1675
SELECT first_name, last_name, birth_year
FROM recruits
WHERE birth_year BETWEEN 1670 AND 1675;
```

## Поиск по шаблону (`LIKE`)

Иногда Петр не помнит точно, как писать фамилию, или ищет всех родственников.

<Conversation :phrases="[
{
name: 'Петр',
position: 'left',
text: 'Был у меня на смотре парень... Фамилия то ли Волков, Воронов... На `Во` начинается, на `ов` заканчивается. Найди-ка его!',
photo: petr
},
{
name: 'Алексей',
position: 'right',
text: 'Тут поможет LIKE. Символ `%` заменяет что угодно, а `_` — одну букву.',
photo: alexey
}
]"/>

- `%` — любая строка (хоть 0, хоть 100 символов).
- `_` — ровно один любой символ.

**Найти всех, чья фамилия начинается на "Во" и заканчивается на "ов":**

```sql
SELECT first_name, last_name
FROM recruits
WHERE last_name LIKE 'Во%ов';
```

**Найти всех с фамилией из 5 букв:**

```sql
SELECT first_name, last_name
FROM recruits
WHERE last_name LIKE '_____'; -- 5 подчеркиваний
```

**Важно:** `LIKE` чувствителен к регистру (большие и маленькие буквы отличаются). Если не уверены, как записали бойца (Попов или попов), используйте **`ILIKE`** (в PostgreSQL) — он игнорирует регистр.

```sql
SELECT first_name, last_name
FROM recruits
WHERE last_name ILIKE '%попов%';
```
