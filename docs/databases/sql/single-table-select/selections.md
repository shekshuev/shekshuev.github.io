---
title: Запросы на выборку данных
---

<script setup>
import Conversation from "../../../../components/Conversation.vue";
import alexey from "../../../assets/databases/heroes/clerk_alexey.png";
import ivan from "../../../assets/databases/heroes/clerk_fedor.png";
import petr from "../../../assets/databases/heroes/petr_young.png";
import { defineAsyncComponent } from "vue";

const Repl = defineAsyncComponent(() => import("../../../../components/Repl.vue"))
</script>

# Отбор строк. Поиск по шаблону

## Введение: Эпоха перемен

**1682 год.** Москва кипит. Скончался царь Фёдор Алексеевич, не оставив наследника. Кремль превратился в поле битвы двух враждующих кланов — Милославских и Нарышкиных.

В воздухе пахнет порохом и кровью. Вспыхивает беспощадный Стрелецкий бунт. Разъяренные стрельцы, подстрекаемые Милославскими, врываются в царские палаты. Итогом кровавой недели становится шаткий компромисс, невиданный ранее на Руси: на трон венчают сразу двух царей. Старшего, болезненного Ивана V, и младшего — десятилетнего, пышущего энергией Петра I. Но реальная власть утекает в руки их старшей сестры, жесткой и властной царевны Софьи.

Юного Петра фактически ссылают из Кремля. Его новым домом становится село **Преображенское** под Москвой. Для кого-то это стало бы опалой, но для Петра это — свобода.

Здесь, вдали от душных боярских палат и интриг, он начинает строить свой собственный мир. Одержимый европейскими науками и военным делом, Петр создает **«Потешные войска»**. Поначалу это кажется детской игрой в солдатики, но очень скоро «потешные» превращаются в грозную силу. Именно здесь, на пыльных полях Преображенского, куется будущая гвардия Российской Империи и закладывается фундамент новой армии.

**1686 год.** Наша история начинается здесь, в штабной избе Преображенского полка. Рядом с молодым Петром трудятся двое государственных служащих.

![Разговор Петра с дьяками](../../../assets/databases/story/petr_talk_with_clerks.png)

- **Дьяк Алексей Транзакциев** — тертый калач, опытный администратор. Он повидал немало на своем веку, умеет вести дела с казной и знает, как усмирить бюрократический хаос.
- **Федор Запросов** — молодой подьячий, сын мелкого приказного. Ему всего 15 лет, он ровесник Петра. Федор попал в Преображенское благодаря острому уму и тяге к порядку. Именно ему предстоит стать «главным по данным» в растущей империи.

<Conversation :phrases="[
    {
        name: 'Петр',
        position: 'left',
        text: 'Алексей! Войско растет не по дням, а по часам. Люди идут со всей Москвы, а у нас в записях — бардак! Кто командует? Где стоят полки? Сколько штыков в строю? Мне нужна полная картина, здесь и сейчас!',
        photo: petr
    },
    {
        name: 'Алексей',
        position: 'right',
        text: 'Не изволь гневаться, государь. Справимся. Федька! Бросай свои перья, берись за дело. Государю нужна полная ведомость всех Потешных полков. Живо!',
        photo: alexey
    },
    {
        name: 'Федор',
        position: 'left',
        text: 'Слушаюсь! Только... таблица огромная, государь. Как мне из неё нужные данные выудить, да чтобы без ошибок?',
        photo: ivan
    }
]"/>

Для начала создадим таблицу `recruits` (Рекруты), которая отражает этот новый, детальный подход к учету личного состава.

::: details Данные для БД

```sql
CREATE TABLE recruits (
    id SERIAL PRIMARY KEY,
    first_name VARCHAR(50),
    last_name VARCHAR(50),
    estate VARCHAR(50), -- Сословие: Дворянин, Мещанин, Крестьянин, Иноземец
    birth_year INTEGER,
    height_cm INTEGER,
    service_start_date DATE
);
INSERT INTO recruits (first_name, last_name, estate, birth_year, height_cm, service_start_date) VALUES
-- Реальные исторические личности
('Сергей', 'Бухвостов', 'Дворянин', 1659, 198, '1683-01-01'), -- Первый солдат, высокий!
('Александр', 'Меншиков', 'Мещанин', 1673, 185, '1686-02-12'), -- Алексашка, молодой
('Франц', 'Лефорт', 'Иноземец', 1656, 178, '1680-05-10'), -- Наставник
('Патрик', 'Гордон', 'Иноземец', 1635, 175, '1680-01-15'), -- Самый старший
('Федор', 'Апраксин', 'Дворянин', 1661, 180, '1683-04-20'),
('Михаил', 'Голицын', 'Дворянин', 1675, 176, '1687-06-01'), -- Совсем юный
('Яков', 'Брюс', 'Иноземец', 1669, 182, '1686-08-14'), -- Брюс
('Аникита', 'Репнин', 'Дворянин', 1668, 184, '1685-03-30'),
('Автоном', 'Головин', 'Дворянин', 1667, 179, '1684-11-20'),
('Иван', 'Бутурлин', 'Дворянин', 1661, 177, '1683-09-12'),
-- Массовка (Дворяне)
('Петр', 'Волков', 'Дворянин', 1668, 185, '1683-06-12'),
('Дмитрий', 'Морозов', 'Дворянин', 1671, 190, '1684-03-01'),
('Николай', 'Новиков', 'Дворянин', 1673, 182, '1685-02-10'),
('Сергей', 'Соловьев', 'Дворянин', 1667, 188, '1683-09-30'),
('Яков', 'Семенов', 'Дворянин', 1669, 184, '1684-05-25'),
('Гаврила', 'Романов', 'Дворянин', 1675, 192, '1685-04-12'),
('Ефим', 'Никитин', 'Дворянин', 1668, 186, '1683-12-01'),
-- Массовка (Крестьяне - их много, они пониже, но есть богатыри)
('Алексей', 'Смирнов', 'Крестьянин', 1665, 175, '1683-05-10'),
('Федор', 'Козлов', 'Крестьянин', 1662, 168, '1683-05-20'),
('Михаил', 'Соколов', 'Крестьянин', 1669, 178, '1683-07-07'),
('Андрей', 'Зайцев', 'Крестьянин', 1660, 165, '1683-04-12'),
('Григорий', 'Титов', 'Крестьянин', 1664, 176, '1683-06-18'),
('Степан', 'Кузнецов', 'Крестьянин', 1661, 169, '1683-05-05'),
('Макар', 'Егоров', 'Крестьянин', 1666, 173, '1683-08-01'),
('Лука', 'Антонов', 'Крестьянин', 1671, 177, '1685-01-20'),
('Илья', 'Муромец', 'Крестьянин', 1660, 195, '1683-02-02'), -- Пасхалка, очень высокий
('Савелий', 'Громов', 'Крестьянин', 1665, 188, '1684-07-15'),
('Прохор', 'Дубов', 'Крестьянин', 1670, 180, '1686-03-03'),
-- Массовка (Мещане)
('Иван', 'Попов', 'Мещанин', 1670, 172, '1684-01-15'),
('Василий', 'Лебедев', 'Мещанин', 1665, 170, '1683-08-22'),
('Павел', 'Борисов', 'Мещанин', 1672, 174, '1684-11-05'),
('Александр', 'Виноградов', 'Мещанин', 1670, 171, '1684-02-14'),
('Тихон', 'Медведев', 'Мещанин', 1663, 167, '1683-10-10'),
('Кузьма', 'Минин', 'Мещанин', 1662, 176, '1683-09-09'), -- Тезка знаменитого
('Ермолай', 'Рыбаков', 'Мещанин', 1668, 169, '1685-06-20'),
-- Еще Иноземцы (для статистики)
('Иоганн', 'Вейс', 'Иноземец', 1660, 176, '1684-01-01'),
('Петер', 'Шмидт', 'Иноземец', 1665, 181, '1685-12-12');
```

:::

<ClientOnly>
<Repl :initial-queries="[
`CREATE TABLE recruits (
    id SERIAL PRIMARY KEY,
    first_name VARCHAR(50),
    last_name VARCHAR(50),
    estate VARCHAR(50), -- Сословие: Дворянин, Мещанин, Крестьянин, Иноземец
    birth_year INTEGER,
    height_cm INTEGER, 
    service_start_date DATE
);`,
`INSERT INTO recruits (first_name, last_name, estate, birth_year, height_cm, service_start_date) VALUES
-- Реальные исторические личности
('Сергей', 'Бухвостов', 'Дворянин', 1659, 198, '1683-01-01'), -- Первый солдат, высокий!
('Александр', 'Меншиков', 'Мещанин', 1673, 185, '1686-02-12'), -- Алексашка, молодой
('Франц', 'Лефорт', 'Иноземец', 1656, 178, '1680-05-10'), -- Наставник
('Патрик', 'Гордон', 'Иноземец', 1635, 175, '1680-01-15'), -- Самый старший
('Федор', 'Апраксин', 'Дворянин', 1661, 180, '1683-04-20'),
('Михаил', 'Голицын', 'Дворянин', 1675, 176, '1687-06-01'), -- Совсем юный
('Яков', 'Брюс', 'Иноземец', 1669, 182, '1686-08-14'), -- Брюс
('Аникита', 'Репнин', 'Дворянин', 1668, 184, '1685-03-30'),
('Автоном', 'Головин', 'Дворянин', 1667, 179, '1684-11-20'),
('Иван', 'Бутурлин', 'Дворянин', 1661, 177, '1683-09-12'),
-- Массовка (Дворяне)
('Петр', 'Волков', 'Дворянин', 1668, 185, '1683-06-12'),
('Дмитрий', 'Морозов', 'Дворянин', 1671, 190, '1684-03-01'),
('Николай', 'Новиков', 'Дворянин', 1673, 182, '1685-02-10'),
('Сергей', 'Соловьев', 'Дворянин', 1667, 188, '1683-09-30'),
('Яков', 'Семенов', 'Дворянин', 1669, 184, '1684-05-25'),
('Гаврила', 'Романов', 'Дворянин', 1675, 192, '1685-04-12'),
('Ефим', 'Никитин', 'Дворянин', 1668, 186, '1683-12-01'),
-- Массовка (Крестьяне - их много, они пониже, но есть богатыри)
('Алексей', 'Смирнов', 'Крестьянин', 1665, 175, '1683-05-10'),
('Федор', 'Козлов', 'Крестьянин', 1662, 168, '1683-05-20'),
('Михаил', 'Соколов', 'Крестьянин', 1669, 178, '1683-07-07'),
('Андрей', 'Зайцев', 'Крестьянин', 1660, 165, '1683-04-12'),
('Григорий', 'Титов', 'Крестьянин', 1664, 176, '1683-06-18'),
('Степан', 'Кузнецов', 'Крестьянин', 1661, 169, '1683-05-05'),
('Макар', 'Егоров', 'Крестьянин', 1666, 173, '1683-08-01'),
('Лука', 'Антонов', 'Крестьянин', 1671, 177, '1685-01-20'),
('Илья', 'Муромец', 'Крестьянин', 1660, 195, '1683-02-02'), -- Пасхалка, очень высокий
('Савелий', 'Громов', 'Крестьянин', 1665, 188, '1684-07-15'),
('Прохор', 'Дубов', 'Крестьянин', 1670, 180, '1686-03-03'),
-- Массовка (Мещане)
('Иван', 'Попов', 'Мещанин', 1670, 172, '1684-01-15'),
('Василий', 'Лебедев', 'Мещанин', 1665, 170, '1683-08-22'),
('Павел', 'Борисов', 'Мещанин', 1672, 174, '1684-11-05'),
('Александр', 'Виноградов', 'Мещанин', 1670, 171, '1684-02-14'),
('Тихон', 'Медведев', 'Мещанин', 1663, 167, '1683-10-10'),
('Кузьма', 'Минин', 'Мещанин', 1662, 176, '1683-09-09'), -- Тезка знаменитого
('Ермолай', 'Рыбаков', 'Мещанин', 1668, 169, '1685-06-20'),
-- Еще Иноземцы (для статистики)
('Иоганн', 'Вейс', 'Иноземец', 1660, 176, '1684-01-01'),
('Петер', 'Шмидт', 'Иноземец', 1665, 181, '1685-12-12');`
]"/>
</ClientOnly>

![задание Федора](../../../assets/databases/story/fedor_first_task.png)

## Команда `SELECT`: Читаем летопись

<Conversation :phrases="[
      {
          name: 'Петр',
          position: 'left',
          text: 'Ну что, Федор? Таблица готова, чернила высохли. Показывай, кого мы там понабрали!',
          photo: petr
      },
      {
          name: 'Федор',
          position: 'right',
          text: 'Готово, мин херц. Но в книге десятки записей... Как мне их все разом тебе представить?',
          photo: ivan
      },
      {
          name: 'Алексей',
          position: 'right',
          text: 'Не суетись. Используй команду SELECT. Это как приказ: «Выбрать». Скажи базе, что хочешь увидеть, и она покажет.',
          photo: alexey
      }
  ]"/>

Базовый синтаксис прост:

```sql
SELECT [столбец 1], [столбец 2] FROM [таблица];
```

### Выборка всех данных (`*`)

Если нужно увидеть **всё и сразу**, используем символ "звездочка" `*`.

```sql
SELECT * FROM recruits;
```

Это удобно для быстрого взгляда на таблицу, но опасно, если в ней миллионы строк. Петр смотрит на длинный список и хмурится: слишком много лишнего. ID, даты... Глаза разбегаются.

::: details Важный совет (Best Practices)
В реальной службе (и в коде программ) старайтесь **всегда перечислять столбцы явно**.

1.  **Экономия:** Зачем тащить из базы дату рождения, если нужны только имена?
2.  **Надежность:** Если структуру таблицы изменят (добавят секретный столбец), ваш код с `SELECT *` может сломаться или выдать тайну.

:::

### Выбор конкретных столбцов

<Conversation :phrases="[
    {
        name: 'Петр',
        position: 'left',
        text: 'Слишком мелко! Мне не нужны номера и даты поступления. Дай мне только Имя, Фамилию и Рост. Хочу видеть, есть ли богатыри!',
        photo: petr
    }
]"/>

Перечисляем только то, что нужно, через запятую:

```sql
SELECT first_name, last_name, height_cm FROM recruits;
```

Теперь список чист и понятен.

## Выражения и арифметика в запросе

SQL — это не просто кладовщик, это еще и счетовод. Мы можем менять данные прямо на лету, не меняя их в самой таблице.

### Объединение строк (Конкатенация)

Вместо двух колонок "Имя" и "Фамилия" сделаем одну красивую — "Боец". В PostgreSQL строки склеиваются оператором `||`.

```sql
SELECT first_name || ' ' || last_name, estate FROM recruits;
```

### Математика

<Conversation :phrases="[
    {
        name: 'Петр',
        position: 'left',
        text: 'Федька, ты мне тут года рождения написал... 1660, 1675... Мне считать лень! Скажи быстро, сколько им лет сейчас, в 1686-м году?',
        photo: petr
    },
    {
        name: 'Федор',
        position: 'right',
        text: 'Сей момент! Сейчас вычту год рождения из текущего года...',
        photo: ivan
    }
]"/>

Мы можем использовать арифметические знаки `+`, `-`, `*`, `/`.
Посчитаем возраст рекрутов (на момент 1686 года):

```sql
SELECT first_name,
       last_name,
       1686 - birth_year
FROM recruits;
```

Как вы уже поняли, команда `SELECT ... FROM ...;` извлекает данные из таблиц. Но `SELECT` умеет работать и без таблиц, выступая в роли мощного калькулятора.

В PostgreSQL (и некоторых других СУБД) ключевое слово `FROM` не является обязательным, если вы просто считаете числа или вызываете системные функции.

```sql
SELECT 2 + 2; -- Сложение
SELECT sqrt(144); -- Квадратный корень
SELECT now(); -- Текущая дата и время
SELECT upper('poltava'); -- Перевод текста в верхний регистр
```

### Работа со временем

Петр планирует наперед. Ему нужно знать, когда у рекрутов закончится первый срок обучения (например, через 3 месяца после поступления).
К датам можно прибавлять интервалы.

```sql
SELECT first_name,
       service_start_date,
       service_start_date + INTERVAL '3 months' AS "Окончание учебки"
FROM recruits;
```

Обратите внимание на формат: `INTERVAL '1 year 2 months 5 days'`. PostgreSQL понимает английские обозначения времени.

## Псевдонимы (`AS`)

Результат прошлого запроса выглядит так: столбец называется `?column?` или как формула. Непорядок.
Дадим столбцам красивые имена (псевдонимы) с помощью `AS`. Если в названии есть пробелы или русские буквы, берем их в **двойные кавычки**.

```sql
SELECT first_name || ' ' || last_name AS "Полное имя",
       1686 - birth_year AS "Возраст"
FROM recruits;
```

## Убираем дубликаты (`DISTINCT`)

<Conversation :phrases="[
    {
        name: 'Петр',
        position: 'left',
        text: 'Алексей, какие вообще сословия у нас представлены? Вижу дворян, вижу крестьян... Кто еще есть? Не читай мне весь список, просто перечисли виды.',
        photo: petr
    },
    {
        name: 'Алексей',
        position: 'right',
        text: 'Для этого, государь, есть слово DISTINCT. Оно убирает повторы и оставляет только уникальные значения.',
        photo: alexey
    }
]"/>

Узнаем, какие уникальные сословия (`estate`) есть в нашем войске:

```sql
SELECT DISTINCT estate FROM recruits;
```

Результат будет коротким: `Дворянин`, `Крестьянин`, `Мещанин`, `Иноземец`.

## Преобразование типов данных (`CAST`)

При выборке данных мы часто сталкиваемся с тем, что тип данных в таблице не подходит для наших вычислений.

<Conversation :phrases="[
  {
    name: 'Петр',
    position: 'left',
    text: 'Федор, сантиметры — это хорошо, но в Голландии считают иначе. Переведи-ка мне рост рекрутов в метры. Просто раздели на 100.',
    photo: petr
  },
  {
    name: 'Федор',
    position: 'right',
    text: 'Сию минуту! Делю height_cm на 100...',
    photo: ivan
  },
  {
    name: 'Петр',
    position: 'left',
    text: 'Что ты мне показываешь?! У тебя и Бухвостов, и Меншиков — все ростом ровно 1 метр? Ты что, всех укоротил?',
    photo: petr
  }
]"/>

Попробуем выполнить приказ "в лоб":

```sql
SELECT last_name,
height_cm,
height_cm / 100 AS height_m
FROM recruits;
```

**Результат:** `1` для всех.

**Почему так?** Столбец `height_cm` имеет тип `INTEGER` (целое число). Когда PostgreSQL делит целое на целое (`175 / 100`), он отбрасывает дробную часть. Получается `1.75` -> `1`.

Чтобы получить дробный ответ, нам нужно превратить (кастовать) целое число в число с плавающей точкой (например, `REAL` или `NUMERIC`).

## Приведение типов

Стандартная функция SQL для смены типа:

```sql
CAST(значение AS новый_тип)
```

Исправим наш запрос:

```sql
SELECT last_name,
height_cm,
CAST(height_cm AS real) / 100 AS height_m
FROM recruits;
```

Теперь `175` превращается в `175.0`, и при делении получается `1.75`.

В PostgreSQL есть более короткий и удобный способ записи — двойное двоеточие `::`.

```sql
значение::новый_тип
```

Давайте переведем рост в метры и сразу красиво округлим результат до двух знаков после запятой, используя тип `numeric`.

```sql
SELECT last_name,
height_cm,
(height_cm::real / 100) AS height_m
FROM recruits;
```

::: tip Заповедь Федора
Всегда следи за типами данных при делении! Если делишь целое на целое — теряешь «хвост». Используй `::real` или `::numeric`.
:::

## Условная логика (`CASE WHEN`)

Данные — это не только то, что записано в ячейках. Иногда нам нужно присваивать категории на лету.

<Conversation :phrases="[
    {
        name: 'Петр',
        position: 'left',
        text: 'Вижу рост, вижу имена... Но кто из них куда годен? Давай так: кто выше 185 см — в гренадеры. Кто от 170 до 185 — в мушкетеры. А коротышек — в обоз, кашу варить!',
        photo: petr
    }
]"/>

Для такой "сортировки по папкам" используется конструкция `CASE WHEN` (Если ... То ...).

Синтаксис:

```sql
CASE
  WHEN условие_1 THEN результат_1
  WHEN условие_2 THEN результат_2
  ELSE результат_иначе
END
```

Применим приказ Петра к нашей таблице:

```sql
SELECT first_name, last_name, height_cm,
CASE
  WHEN height_cm >= 185 THEN 'Гренадерская рота'
  WHEN height_cm >= 170 THEN 'Мушкетерская рота'
  ELSE 'Обозная команда'
END AS military_branch
FROM recruits
```

Теперь у нас появился новый (вычисляемый) столбец `military_branch`, которого физически нет в базе, но он есть в отчете.

::: tip Порядок условий
База данных проверяет условия сверху вниз. Как только одно подошло, она останавливается. Поэтому самые строгие условия (гренадеры > 185) лучше писать первыми.
:::

## Фильтрация данных (`WHERE`)

Выборка — это хорошо. Но Петру редко нужны **все**. Ему нужны конкретные люди для конкретных задач.
Для этого используется оператор `WHERE` (ГДЕ). Он оставляет только те строки, где условие истинно (`true`).

Синтаксис:

```sql
SELECT ... FROM ... WHERE [условие];
```

### Простые сравнения

Петр формирует первую гренадерскую роту. Туда берут только высоких.

<Conversation :phrases="[
    {
        name: 'Петр',
        position: 'left',
        text: 'Федор! Мне нужны великаны. Выпиши мне всех, кто выше 180 сантиметров. Остальные пусть пока в обозе сидят.',
        photo: petr
    }
]"/>

Используем операторы сравнения: `>`, `<`, `=`, `>=`, `<=`, `<>` (не равно).

```sql
SELECT first_name, last_name, height_cm
FROM recruits
WHERE height_cm > 180;
```

А теперь найдем всех иностранцев (Иноземцев), чтобы Петр мог попрактиковаться в немецком и голландском языках.

```sql
SELECT first_name, last_name, estate
FROM recruits
WHERE estate = 'Иноземец';
```

### Логические операторы (`AND`, `OR`)

Жизнь сложнее одного условия.

<Conversation :phrases="[
    {
        name: 'Петр',
        position: 'left',
        text: 'Так, нужны толковые офицеры. Найди мне дворян. Но не старых дедов, а молодых, кто родился после 1665 года!',
        photo: petr
    }
]"/>

- `AND` (И) — оба условия должны быть верны.
- `OR` (ИЛИ) — хотя бы одно условие верно.

```sql
SELECT first_name, last_name, estate, birth_year
FROM recruits
WHERE estate = 'Дворянин' AND birth_year > 1665;
```

А теперь найдем всех, кто годится либо в гренадеры (высокие, > 185), либо в иноземные инструкторы (сословие 'Иноземец').

```sql
SELECT first_name, last_name, estate, height_cm
FROM recruits
WHERE height_cm > 185 OR estate = 'Иноземец';
```

Чтобы не писать длинные цепочки `OR` и `AND`, есть сокращения.

### `IN` (В списке)

Петр хочет собрать полк из простых людей: крестьян и мещан.

```sql
-- Вместо: WHERE estate = 'Крестьянин' OR estate = 'Мещанин'
SELECT first_name, last_name, estate
FROM recruits
WHERE estate IN ('Крестьянин', 'Мещанин');
```

### `BETWEEN` (Между)

Ищем ровесников Петра (родившихся между 1670 и 1675 годами).

```sql
-- Вместо: WHERE birth_year >= 1670 AND birth_year <= 1675
SELECT first_name, last_name, birth_year
FROM recruits
WHERE birth_year BETWEEN 1670 AND 1675;
```

### Работа с неизвестным (`IS NULL`)

В суматохе писари могли забыть измерить рост новобранца или не спросить, откуда он родом. В базе данных такие пропуски называются `NULL`.
Это не ноль и не пустая строка. Это **«ничто»**, неизвестность.

<Conversation :phrases="[
    {
        name: 'Петр',
        position: 'left',
        text: 'Алексей, а что у нас с теми, кого вчера пригнали? Почему в графе «Рост» пустота?',
        photo: petr
    },
    {
        name: 'Алексей',
        position: 'right',
        text: 'Не успели измерить, мин херц. Лекарь запил. Надо бы их найти и отправить на перемерку.',
        photo: alexey
    }
]"/>

**Важно:** С `NULL` нельзя использовать обычное равно (`=`). «Ничто» не равно «ничему».
Для поиска пустоты используется оператор `IS NULL`.

```sql
-- Найти всех, у кого не указан рост
SELECT first_name, last_name
FROM recruits
WHERE height_cm IS NULL;
```

А чтобы найти тех, у кого данные **заполнены**, используем `IS NOT NULL`.

```sql
-- Найти всех, у кого рост известен
SELECT first_name, last_name
FROM recruits
WHERE height_cm IS NOT NULL;
```

### Поиск по шаблону (`LIKE`)

Иногда Петр не помнит точно, как писать фамилию, или ищет всех родственников.

<Conversation :phrases="[
{
name: 'Петр',
position: 'left',
text: 'Был у меня на смотре парень... Фамилия то ли Волков, Воронов... На `Во` начинается, на `ов` заканчивается. Найди-ка его!',
photo: petr
},
{
name: 'Алексей',
position: 'right',
text: 'Тут поможет LIKE. Символ `%` заменяет что угодно, а `_` — одну букву.',
photo: alexey
}
]"/>

- `%` — любая строка (хоть 0, хоть 100 символов).
- `_` — ровно один любой символ.

**Найти всех, чья фамилия начинается на "Во" и заканчивается на "ов":**

```sql
SELECT first_name, last_name
FROM recruits
WHERE last_name LIKE 'Во%ов';
```

**Найти всех с фамилией из 5 букв:**

```sql
SELECT first_name, last_name
FROM recruits
WHERE last_name LIKE '_____'; -- 5 подчеркиваний
```

**Важно:** `LIKE` чувствителен к регистру (большие и маленькие буквы отличаются). Если не уверены, как записали бойца (Попов или попов), используйте **`ILIKE`** (в PostgreSQL) — он игнорирует регистр.

```sql
SELECT first_name, last_name
FROM recruits
WHERE last_name ILIKE '%попов%';
```

::: tip Как найти сам знак процента?
Если вдруг в имени рекрута затесался странный символ (например, писарь случайно написал `Иван_Дурак` или `Процент%`), а вам нужно найти именно его?
Ведь `_` и `%` — это спецсимволы.
Используйте `ESCAPE`.

```sql
-- Ищет строку, где реально есть символ подчеркивания
SELECT * FROM recruits WHERE last_name LIKE '%\_%';
```

В данном случае обратный слеш `\` (по умолчанию) говорит базе: "Считай следующий символ просто текстом, а не командой".
:::

## Регулярные выражения в SQL

Запросы Петра становятся всё изощреннее. Ему уже мало просто найти «Иванова». Ему подавай сложные комбинации букв, чтобы выявить редкие фамилии или проверить грамотность писарей.

<Conversation :phrases="[
    {
        name: 'Петр',
        position: 'left',
        text: 'Федька! Найди мне всех, у кого имя начинается на А или на И. Или тех, у кого в фамилии две буквы «о» подряд. И чтобы имя было коротким!',
        photo: petr
    },
    {
        name: 'Федор',
        position: 'left',
        text: 'Мин херц, я уже десятое условие OR пишу... Чернила кончаются, пальцы сводит! Твой LIKE тут не справляется!',
        photo: ivan
    },
    {
        name: 'Алексей',
        position: 'right',
        text: 'Отставь панику. Для таких хитрых приказов у нас есть особое оружие — регулярные выражения. Это как шифр: пишешь пару знаков, а машина понимает целый абзац условий.',
        photo: alexey
    }
]"/>

### Оператор `SIMILAR TO`

Это гибрид. Он похож на `LIKE` (использует `%` и `_`), но понимает некоторые команды из мира регулярных выражений:

- `|` (или) — выбор из вариантов.
- `[]` — набор символов.
- `{n}` — количество повторений.

Примеры:

**Найти всех, чье имя начинается на "А" или "И":**

```sql
SELECT first_name, last_name
FROM recruits
WHERE first_name SIMILAR TO '(А|И)%';
```

**Найти всех, у кого имя начинается с любой гласной буквы:**

```sql
SELECT first_name, last_name
FROM recruits
WHERE first_name SIMILAR TO '[АЕЁИОУЫЭЮЯ]%';
```

**Найти всех с фамилиями на «-ов» или «-ин»:**

```sql
SELECT last_name, estate
FROM recruits
WHERE last_name SIMILAR TO '%(ов|ин)';
```

**Найти всех, чье имя начинается на буквы М, П или С:**

```sql
SELECT first_name, last_name
FROM recruits
WHERE first_name SIMILAR TO '[МПС]%';
```

**Найти имена, где вторая буква — «е» или «ё»:**

```sql
SELECT first*name
FROM recruits
WHERE first_name SIMILAR TO '_[её]%';
```

**Найти всех, у кого имя состоит ровно из 5 букв:**

```sql
SELECT first_name
FROM recruits
WHERE first_name SIMILAR TO '[а-яА-Я]{5}';
```

### POSIX Регулярные выражения (`~`)

Это самый мощный, но и самый сложный инструмент. Он используется в UNIX-системах.

- `~` — ищет совпадение (с учетом регистра).
- `~*` — ищет совпадение (без учета регистра).
- `!~` — ищет **НЕ** совпадение.

**Найти всех, у кого имя начинается на «А» (знак `^` — начало строки):**

```sql
SELECT first_name, last_name
FROM recruits
WHERE first_name ~ '^А';
```

**Найти всех, у кого имя заканчивается на «й» (знак `$` — конец строки):**

```sql
SELECT first_name, last_name
FROM recruits
WHERE first_name ~ 'й$';
```

**Найти имена длиной ровно от 3 до 5 букв:**

```sql
SELECT first_name
FROM recruits
WHERE first_name ~ '^.{3,5}$';
```

**Найти тех, у кого в фамилии НЕТ буквы «о» (ни большой, ни маленькой):**

```sql
SELECT last_name
FROM recruits
WHERE last_name !~* 'о';
```

**Найти имена, заканчивающиеся на гласную (а, я, и):**

```sql
SELECT first_name
FROM recruits
WHERE first_name ~ '[аяи]$';
```

**Сложный фильтр: Имя начинается на «А», содержит «л», и это не Иноземец:**

```sql
SELECT first_name, last_name, estate
FROM recruits
WHERE first_name ~ '^А.*л' AND estate != 'Иноземец';
```

## Псевдонимы таблиц

Когда запросы становятся большими, писать полное название таблицы `recruits` каждый раз утомительно. Мы можем дать таблице короткое имя (алиас) прямо в запросе.

<Conversation :phrases="[
    {
        name: 'Федор',
        position: 'left',
        text: 'Алексей, рука устала писать recruits в каждой строчке. Можно как-то покороче?',
        photo: ivan
    }
]"/>

```sql
SELECT r.first_name, r.last_name
FROM recruits r -- "r" — это теперь псевдоним таблицы
WHERE r.estate = 'Дворянин';
```

Это кажется ненужным сейчас, когда таблица одна. Но когда мы будем соединять полки с командирами и оружием (в следующих занятиях), сокращения вроде:
`FROM soldiers s JOIN weapons w`
сэкономят вам кучу времени и нервов.

## Сохранение результатов (`SELECT INTO`)

Иногда Петру не просто нужно посмотреть отчет, а создать на его основе новый полковой список для похода.
Команда `SELECT INTO` создает новую таблицу и сразу наполняет её результатами запроса.

<Conversation :phrases="[
    {
        name: 'Петр',
        position: 'left',
        text: 'Федор, выбери мне всех высоких дворян и запиши их в отдельную книгу «Гвардия». Будем их учить по-новому.',
        photo: petr
    }
]"/>

```sql
SELECT first_name, last_name, height_cm
INTO elite_guard -- Новая таблица создастся сама
FROM recruits
WHERE estate = 'Дворянин' AND height_cm > 180;
```

Теперь в базе данных появилась новая таблица `elite_guard`.

## Что выбрать для поиска?

В арсенале Федора теперь много инструментов. Но какой из них доставать из ножен? Дьяк Алексей дает наставление.

<Conversation :phrases="[
    {
        name: 'Алексей',
        position: 'right',
        text: 'Запомни, Федор: не пали из пушки по воробьям. Самый быстрый способ найти человека — это простое равенство. Если не знаешь точно — бери LIKE. А регулярки оставь на самый крайний случай, они тяжелые для казны (ресурсов сервера).',
        photo: alexey
    }
]"/>

::: tip Шпаргалка по производительности (от быстрого к медленному)

1.  **`=` (Равно)**: Самый быстрый. Использует индексы.
    - _Пример:_ `WHERE id = 10`
2.  **`LIKE 'abc%'` (С префиксом)**: Быстрый. Может использовать индекс.
    - _Пример:_ `WHERE last_name LIKE 'Иван%'`
3.  **`ILIKE`**: Чуть медленнее `LIKE`, так как тратит время на приведение регистра.
4.  **`LIKE '%abc'` (С % в начале)**: **Медленно!** Базе придется перечитать всю таблицу целиком (Full Scan), индексы не помогут.
5.  **`SIMILAR TO`**: Медленнее, чем `LIKE`. Сложная логика.
6.  **`~` (Регулярные выражения)**: Самый мощный, но самый медленный инструмент. Используйте только для сложных шаблонов.

:::

## Выводы по учебному вопросу

Федор вытер пот со лба. Ведомость готова: дворяне отделены от крестьян, гренадеры найдены, иноземцы посчитаны. Но Петр, взглянув на отчет, нахмурился.

<Conversation :phrases="[
    {
        name: 'Петр',
        position: 'left',
        text: 'Неплохо, Федор. Людей вижу. Но почему они стоят как попало? Иванов, потом Яковлев, потом опять Андреев... Где строй? Где ранжир?!',
        photo: petr
    },
    {
        name: 'Федор',
        position: 'right',
        text: 'Виноват, мин херц! Порядок наведем сию минуту.',
        photo: ivan
    }
]"/>

**Сегодня мы научились:**

1.  **Выбирать данные (`SELECT`)**: Брать не всё подряд, а только нужные столбцы, использовать псевдонимы и арифметику.
2.  **Фильтровать строки (`WHERE`)**: Отсеивать лишнее с помощью точных совпадений, диапазонов (`BETWEEN`) и списков (`IN`).
3.  **Искать по тексту**:
    - `LIKE` — для простых шаблонов («начинается на...»).
    - `SIMILAR TO` и `~` — для сложного поиска внутри строк.
4.  **Категоризировать (`CASE WHEN`)**: Создавать новые смыслы (гренадер/мушкетер) на основе сухих цифр.
5.  **Работать с типами**: Превращать сантиметры в метры (`CAST`) и находить пустоту (`IS NULL`).

В следующем учебном вопросе мы научимся наводить идеальный порядок в наших данных с помощью **Сортировки** и получать красивую статистику через **Группировку**.
