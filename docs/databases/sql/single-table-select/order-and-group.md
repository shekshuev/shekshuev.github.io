---
title: Запросы на выборку данных
---

<script setup>
import Conversation from "../../../../components/Conversation.vue";
import alexey from "../../../assets/databases/heroes/clerk_alexey.png";
import ivan from "../../../assets/databases/heroes/clerk_fedor.png";
import petr from "../../../assets/databases/heroes/petr_young.png";
import { defineAsyncComponent } from "vue";

const Repl = defineAsyncComponent(() => import("../../../../components/Repl.vue"))
</script>

# Сортировка и группировка данных

## Введение: От хаоса к порядку

Федор протянул Петру длинный список рекрутов. Царь пробежал глазами по строкам, и лицо его помрачнело.

<Conversation :phrases="[
    {
        name: 'Петр',
        position: 'left',
        text: 'Это что за салат, Федор? Иванов, потом Яковлев, потом Абрамов... Высокий, низкий, дворянин, конюх — все в кучу! Как я должен по этому списку полки строить?',
        photo: petr
    },
    {
        name: 'Федор',
        position: 'right',
        text: 'Но, мин херц, ты просил выбрать всех... Я и выбрал. База данных отдает их в том порядке, как записали.',
        photo: ivan
    },
    {
        name: 'Алексей',
        position: 'right',
        text: 'Не беда. Данные у нас есть, теперь их нужно причесать. В SQL для этого есть команда ORDER BY — «Упорядочить по».',
        photo: alexey
    }
]"/>

По умолчанию база данных не гарантирует никакого порядка. Строки возвращаются так, как удобно серверу (обычно в порядке их добавления на диск). Чтобы выстроить их в строй, нужно явно приказать.

<ClientOnly>
<Repl :initial-queries="[
`CREATE TABLE recruits (
    id SERIAL PRIMARY KEY,
    first_name VARCHAR(50),
    last_name VARCHAR(50),
    estate VARCHAR(50), -- Сословие: Дворянин, Мещанин, Крестьянин, Иноземец
    birth_year INTEGER,
    height_cm INTEGER, 
    service_start_date DATE
);`,
`INSERT INTO recruits (first_name, last_name, estate, birth_year, height_cm, service_start_date) VALUES
-- Реальные исторические личности
('Сергей', 'Бухвостов', 'Дворянин', 1659, 198, '1683-01-01'), -- Первый солдат, высокий!
('Александр', 'Меншиков', 'Мещанин', 1673, 185, '1686-02-12'), -- Алексашка, молодой
('Франц', 'Лефорт', 'Иноземец', 1656, 178, '1680-05-10'), -- Наставник
('Патрик', 'Гордон', 'Иноземец', 1635, 175, '1680-01-15'), -- Самый старший
('Федор', 'Апраксин', 'Дворянин', 1661, 180, '1683-04-20'),
('Михаил', 'Голицын', 'Дворянин', 1675, 176, '1687-06-01'), -- Совсем юный
('Яков', 'Брюс', 'Иноземец', 1669, 182, '1686-08-14'), -- Брюс
('Аникита', 'Репнин', 'Дворянин', 1668, 184, '1685-03-30'),
('Автоном', 'Головин', 'Дворянин', 1667, 179, '1684-11-20'),
('Иван', 'Бутурлин', 'Дворянин', 1661, 177, '1683-09-12'),
-- Массовка (Дворяне)
('Петр', 'Волков', 'Дворянин', 1668, 185, '1683-06-12'),
('Дмитрий', 'Морозов', 'Дворянин', 1671, 190, '1684-03-01'),
('Николай', 'Новиков', 'Дворянин', 1673, 182, '1685-02-10'),
('Сергей', 'Соловьев', 'Дворянин', 1667, 188, '1683-09-30'),
('Яков', 'Семенов', 'Дворянин', 1669, 184, '1684-05-25'),
('Гаврила', 'Романов', 'Дворянин', 1675, 192, '1685-04-12'),
('Ефим', 'Никитин', 'Дворянин', 1668, 186, '1683-12-01'),
-- Массовка (Крестьяне - их много, они пониже, но есть богатыри)
('Алексей', 'Смирнов', 'Крестьянин', 1665, 175, '1683-05-10'),
('Федор', 'Козлов', 'Крестьянин', 1662, 168, '1683-05-20'),
('Михаил', 'Соколов', 'Крестьянин', 1669, 178, '1683-07-07'),
('Андрей', 'Зайцев', 'Крестьянин', 1660, 165, '1683-04-12'),
('Григорий', 'Титов', 'Крестьянин', 1664, 176, '1683-06-18'),
('Степан', 'Кузнецов', 'Крестьянин', 1661, 169, '1683-05-05'),
('Макар', 'Егоров', 'Крестьянин', 1666, 173, '1683-08-01'),
('Лука', 'Антонов', 'Крестьянин', 1671, 177, '1685-01-20'),
('Илья', 'Муромец', 'Крестьянин', 1660, 195, '1683-02-02'), -- Пасхалка, очень высокий
('Савелий', 'Громов', 'Крестьянин', 1665, 188, '1684-07-15'),
('Прохор', 'Дубов', 'Крестьянин', 1670, 180, '1686-03-03'),
-- Массовка (Мещане)
('Иван', 'Попов', 'Мещанин', 1670, 172, '1684-01-15'),
('Василий', 'Лебедев', 'Мещанин', 1665, 170, '1683-08-22'),
('Павел', 'Борисов', 'Мещанин', 1672, 174, '1684-11-05'),
('Александр', 'Виноградов', 'Мещанин', 1670, 171, '1684-02-14'),
('Тихон', 'Медведев', 'Мещанин', 1663, 167, '1683-10-10'),
('Кузьма', 'Минин', 'Мещанин', 1662, 176, '1683-09-09'), -- Тезка знаменитого
('Ермолай', 'Рыбаков', 'Мещанин', 1668, 169, '1685-06-20'),
-- Еще Иноземцы (для статистики)
('Иоганн', 'Вейс', 'Иноземец', 1660, 176, '1684-01-01'),
('Петер', 'Шмидт', 'Иноземец', 1665, 181, '1685-12-12');`
]"/>
</ClientOnly>

## Сортировка (`ORDER BY`)

Для сортировки используется конструкция `ORDER BY`, которая ставится в самом конце запроса (после `WHERE`).

Синтаксис:

```sql
SELECT ...
FROM ...
WHERE ...
ORDER BY столбец [ASC | DESC];
```

- `ASC` (Ascending) — по возрастанию (А-Я, 0-9). **Используется по умолчанию**.
- `DESC` (Descending) — по убыванию (Я-А, 9-0).

### Алфавитный порядок

Петр хочет видеть список личного состава для переклички. Тут нужен алфавит.

```sql
SELECT first_name, last_name, estate
FROM recruits
ORDER BY last_name ASC; -- ASC можно не писать, оно само подставится
```

### Сортировка по убыванию (`DESC`)

А теперь строим **Гренадерскую роту**. В неё берут самых высоких и сильных. Нам нужно, чтобы «великаны» были в начале списка.

<Conversation :phrases="[
    {
        name: 'Петр',
        position: 'left',
        text: 'Федор! Самых высоких — в первый ряд! Коротышек — назад. Стройся!',
        photo: petr
    }
]"/>

```sql
SELECT first_name, last_name, height_cm
FROM recruits
ORDER BY height_cm DESC;
```

Теперь первым в списке будет Сергей Бухвостов (198 см), а в конце — Андрей Зайцев (165 см).

## Многоуровневая сортировка

В армии важна иерархия. Петр хочет, чтобы список был разбит по сословиям, а внутри каждого сословия люди шли по старшинству (от старых к молодым).

Мы можем указывать несколько столбцов через запятую.

```sql
SELECT estate, last_name, birth_year
FROM recruits
ORDER BY estate ASC, birth_year ASC;
```

**Как это работает:**

1.  Сначала СУБД сортирует всех по `estate` (Дворяне, Иноземцы, Крестьяне...).
2.  Если у двух людей сословие одинаковое (например, оба Дворяне), то их сравнивают по `birth_year`.

## Проблема неизвестности (`NULLS FIRST / LAST`)

Вспоминаем, что у некоторых рекрутов рост не был измерен (`NULL`).
При сортировке PostgreSQL считает `NULL` **самым большим значением**.

- При `ASC` (возрастание) пустые значения улетят в **конец**.
- При `DESC` (убывание) пустые значения вылезут в **начало**.

<Conversation :phrases="[
    {
        name: 'Петр',
        position: 'left',
        text: 'Я просил высоких, а ты мне кого подсунул? У этого в графе рост — пустота! Убрать неопознанных в конец строя!',
        photo: petr
    },
    {
        name: 'Алексей',
        position: 'right',
        text: 'Для этого есть уточнение NULLS LAST (пустые в конец) или NULLS FIRST (пустые в начало).',
        photo: alexey
    }
]"/>

Исправим наш список гренадеров:

```sql
SELECT first_name, last_name, height_cm
FROM recruits
ORDER BY height_cm DESC NULLS LAST;
```

Теперь сначала идут высокие, потом низкие, и только в самом конце — те, кого забыли измерить.

## Ограничение выборки (`LIMIT` и `OFFSET`)

Иногда Петру не нужен весь полк. Ему нужна только элита или дежурная смена.

### Топ лучших (`LIMIT`)

Петр набирает личную охрану. Ему нужно только **5 самых высоких** бойцов.

```sql
SELECT first_name, last_name, height_cm
FROM recruits
ORDER BY height_cm DESC NULLS LAST
LIMIT 5;
```

База данных отсортирует всех, отсчитает первые 5 строк и остановится. Остальные данные отбросятся.

### Пагинация (`OFFSET`)

Первая пятерка ушла в караул. Теперь нужно выбрать **следующих 5 человек** для второй смены.
Для этого нужно «пропустить» первые 5 строк.

```sql
SELECT first_name, last_name, height_cm
FROM recruits
ORDER BY height_cm DESC NULLS LAST
LIMIT 5 OFFSET 5;
```

- `OFFSET 5` — пропусти первые 5 записей.
- `LIMIT 5` — возьми следующие 5.

<Conversation :phrases="[
    {
        name: 'Федор',
        position: 'right',
        text: 'Списки ровные, государь! Высокие впереди, низкие сзади. Любо-дорого смотреть.',
        photo: ivan
    },
    {
        name: 'Петр',
        position: 'left',
        text: 'Добро. Но говорить со всеми сразу я не буду. Мне нужны старшие. Выбери-ка мне по одному представителю от каждого сословия. И пусть это будут самые высокие — они виднее в строю!',
        photo: petr
    },
    {
        name: 'Федор',
        position: 'right',
        text: 'Так... Если я сделаю DISTINCT estate, я получу просто названия сословий, без имен... А если оставлю имена, то DISTINCT не сработает...',
        photo: ivan
    },
    {
        name: 'Алексей',
        position: 'right',
        text: 'Здесь обычный DISTINCT не поможет. Нам нужен особый инструмент PostgreSQL — DISTINCT ON. Он позволяет выбрать одну строку из группы, сохранив остальные данные.',
        photo: alexey
    }
]"/>

## Продвинутая уникальность (`DISTINCT ON`)

Это мощнейшая фишка PostgreSQL, которой нет во многих других базах данных. Она позволяет сказать: "Отсортируй их по группам, и оставь только **первого** из каждой группы".

```sql
SELECT DISTINCT ON (estate) estate, first_name, last_name, height_cm
FROM recruits
ORDER BY estate, height_cm DESC;
```

**Как это работает:**

1.  СУБД сортирует всех сначала по сословию (`estate`), потом по убыванию роста (`height_cm DESC`).
2.  Берет **первую** строку из каждой группы "Сословие".
3.  Остальные отбрасывает.

В итоге Петр увидит самого высокого дворянина, самого высокого крестьянина и т.д.

# Агрегатные функции: От списков к цифрам

Списки составлены, но Петру этого мало. Ему нужны сводные данные для принятия стратегических решений.

<Conversation :phrases="[
    {
        name: 'Петр',
        position: 'left',
        text: 'Федор, мне не нужны имена всех тысячи человек! Мне нужно знать главное: сколько денег готовить на жалованье? Сколько аршин сукна купить на мундиры? И есть ли у нас совсем дети?',
        photo: petr
    },
    {
        name: 'Федор',
        position: 'right',
        text: 'Сейчас, мин херц... Буду складывать в уме... Один, два, три...',
        photo: ivan
    },
    {
        name: 'Алексей',
        position: 'right',
        text: 'Брось счетами стучать. У базы есть Агрегатные функции. Они берут столбец цифр, перемалывают его и выдают одно итоговое число.',
        photo: alexey
    }
]"/>

Агрегатные функции сжимают множество строк в одну.

### Основные функции

- `COUNT(*)` — посчитать количество строк.
- `SUM(столбец)` — сумма значений.
- `AVG(столбец)` — среднее арифметическое.
- `MIN(столбец)` — минимальное значение.
- `MAX(столбец)` — максимальное значение.

### Перекличка (`COUNT`)

Посчитаем, сколько всего душ в нашем полку.

```sql
SELECT COUNT(*) FROM recruits;
```

::: tip Нюанс с NULL

- `COUNT(*)` считает **все строки**, даже если там сплошные NULL.
- `COUNT(столбец)` считает только те строки, где в этом столбце **не пусто**.
  :::

### Разведка боем (`MIN` и `MAX`)

Петр хочет узнать, кто самый высокий (для флангового) и самый низкий (в барабанщики). А также годы рождения самого старого и самого молодого.

```sql
SELECT MAX(height_cm) as max_height,
       MIN(height_cm) as min_height,
       MAX(birth_year) as youngest_year, -- Чем больше год, тем моложе человек
       MIN(birth_year) as oldest_year
FROM recruits;
```

### Бюджет и снабжение (`SUM` и `AVG`)

Вычислим средний рост солдата, чтобы портные знали, какого размера шить кафтаны.

```sql
SELECT AVG(height_cm)::numeric(5,2) as avg_height
FROM recruits;
```

::: warning Ловушка среднего (`AVG` и `NULL`)
Агрегатные функции (кроме `COUNT(*)`) **игнорируют NULL**.
Если у вас 10 солдат, но у 5 из них рост неизвестен (`NULL`), то `AVG` сложит рост 5 измеренных и разделит на 5.
Если вы хотите считать неизвестных как "0", нужно использовать функцию `COALESCE(height_cm, 0)`, но это сильно исказит статистику роста!
:::

# Группировка данных (`GROUP BY`)

Теперь Петр хочет видеть статистику не по всей армии скопом, а в разрезе сословий.

<Conversation :phrases="[
    {
        name: 'Петр',
        position: 'left',
        text: 'Общая цифра — это хорошо. Но мне нужно знать, сколько у нас дворян, а сколько крестьян? Кто из них выше ростом?',
        photo: petr
    },
    {
        name: 'Федор',
        position: 'right',
        text: 'Я попробую так...',
        photo: ivan
    }
]"/>

Федор пишет такой запрос и получает ошибку:

```sql
-- ОШИБКА!
SELECT estate, COUNT(*)
FROM recruits;
```

**Почему это не работает?**
Давайте разберем логику машины.

1.  Вы просите вывести столбец `estate`. В нем, допустим, **100 строк** (Дворянин, Крестьянин, Дворянин...).
2.  Вы просите вывести `COUNT(*)`. Это **одно число** (100).
3.  Как таблице состыковать 100 строк слева и 1 число справа? В какую строку записать итог?
    Это невозможно. Таблица должна быть прямоугольной.

### Принцип схлопывания

Чтобы этот запрос сработал, нам нужно "сплющить" (сгруппировать) все строки с одинаковым сословием в одну.
Для этого используется `GROUP BY`.

```sql
SELECT estate, COUNT(*)
FROM recruits
GROUP BY estate;
```

**Что происходит под капотом:**

1.  База данных берет все строки.
2.  Сортирует их по «корзинам» (группам): корзина "Дворяне", корзина "Крестьяне", корзина "Мещане".
3.  Все имена и фамилии внутри корзины **исчезают** (схлопываются).
4.  Для каждой корзины вычисляется агрегатная функция (`COUNT`, `AVG` и т.д.).
5.  На выходе мы получаем по одной строке на каждую группу.

### Практика: Анализ по сословиям

Давайте узнаем средний рост и количество людей в каждом сословии.

```sql
SELECT estate,
       COUNT(*) as people_count,
       AVG(height_cm)::numeric(5,1) as avg_height
FROM recruits
GROUP BY estate
ORDER BY avg_height DESC;
```

Теперь мы видим, что, например, дворяне в среднем выше крестьян (потому что лучше питались в детстве).

### Группировка по нескольким колонкам

Петр усложняет задачу.

<Conversation :phrases="[
    {
        name: 'Петр',
        position: 'left',
        text: 'А как у нас с возрастом по сословиям? Может, дворяне у нас все старики, а крестьяне — юнцы?',
        photo: petr
    }
]"/>

Мы можем группировать по нескольким признакам сразу. Сгруппируем по Сословию И Году рождения.

```sql
SELECT estate, birth_year, COUNT(*)
FROM recruits
GROUP BY estate, birth_year
ORDER BY estate, birth_year;
```

Здесь "схлопывание" произойдет только для тех строк, где совпадают **оба** значения (и сословие, и год).

## Отсев групп (`HAVING`)

Петр смотрит на отчет и видит кучу мелких групп.

<Conversation :phrases="[
    {
        name: 'Петр',
        position: 'left',
        text: 'Зачем мне в отчете сословия, где всего по 1-2 человека? Это статистическая погрешность! Убери их, оставь только массовые категории.',
        photo: petr
    },
    {
        name: 'Федор',
        position: 'right',
        text: 'Легко! Добавлю WHERE...',
        photo: ivan
    }
]"/>

Федор снова пишет запрос и получает ошибку:

```sql
-- ОШИБКА!
SELECT estate, COUNT(*)
FROM recruits
WHERE COUNT(*) > 2 -- Так нельзя!
GROUP BY estate;
```

::: danger Заповедь Алексея
`WHERE` работает **ДО** группировки. Он фильтрует сырые строки (конкретных людей).
В момент работы `WHERE` база еще не знает, сколько людей будет в группе, она еще не считала.

Чтобы отфильтровать **результат группировки**, используй `HAVING`.
:::

Правильный запрос:

```sql
SELECT estate, COUNT(*)
FROM recruits
GROUP BY estate
HAVING COUNT(*) > 2;
```

**Порядок выполнения запроса (ЭТО ВАЖНО):**

1.  `FROM` (взяли таблицу)
2.  `WHERE` (отсеяли лишних людей, например, уволенных)
3.  `GROUP BY` (собрали оставшихся в кучи)
4.  `HAVING` (отсеяли маленькие кучи)
5.  `SELECT` (посчитали числа для вывода)
6.  `ORDER BY` (отсортировали итог)
7.  `OFFSET` / `LIMIT` (взяли нужную выборку)

## Выводы по второму вопросу

Петр долго изучал сводную ведомость. Палец царя скользил по ровным колонкам цифр: бюджеты полков, средний рост гренадеров, количество штыков. Хаос исчез. На пергаменте была видна структура будущей армии.

<Conversation :phrases="[
    {
        name: 'Петр',
        position: 'left',
        text: 'Добро, Федор. Теперь я вижу не толпу, а войско. Цифры сходятся, казна под контролем. Но в бою некогда листать талмуды. Писарь должен соображать быстро!',
        photo: petr
    },
    {
        name: 'Федор',
        position: 'right',
        text: 'Готов, мин херц! Испытывай.',
        photo: ivan
    },
    {
        name: 'Алексей',
        position: 'right',
        text: 'Государь сейчас задаст тебе ряд тактических задач. Это будет твой экзамен. Справишься — допустим до настоящих маневров.',
        photo: alexey
    }
]"/>

**Чему мы научились в этом разделе:**

1.  **Наводить порядок (`ORDER BY`)**: Выстраивать данные по алфавиту, росту или важности.
2.  **Работать с лучшими (`LIMIT` / `OFFSET`)**: Отбирать только верхушку списка или делать выборку частями.
3.  **Считать и усреднять значения (Агрегатные функции)**: Использовать `COUNT`, `SUM`, `AVG`, `MIN`, `MAX` для получения статистики.
4.  **Мыслить масштабно (`GROUP BY`)**: Анализировать не отдельных людей, а целые категории (сословия, полки).
5.  **Отсекать лишнее (`HAVING`)**: Фильтровать группы уже после того, как они были собраны.

### Историческая справка: На пороге больших маневров

Шли годы. Детские игры в Преображенском закончились. «Потешные» полки выросли и превратились в грозную силу — будущую Лейб-гвардию.

На горизонте **1694 год**. Петр задумывает **Кожуховский поход** — грандиозные военные учения, по масштабу не уступающие реальной войне. Строятся крепости, роются траншеи, армия делится на две стороны.

Но для таких маневров одной таблицы `recruits` уже мало.

- У солдат появляются ружья и пушки (таблица `weapons`).
- Назначаются офицеры и генералы (таблица `commanders`).
- Полки получают знамена и названия (таблица `regiments`).

Чтобы связать всё это воедино и понять, _«Какой командир какой пушкой управляет?»_, нам понадобятся связи между таблицами.

Но это будет на следующем занятии. А пока — **Учебный вопрос №3. Разработка вопросов на выбоку данных**. Петр ждет решений!
